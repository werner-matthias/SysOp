---
title: Another incompatible and hackneyed Pi Operating System
layout: page-fullwidth
author: mwerner
show_meta: true
subheadline: Ein Betriebsystem f√ºr die Lehre
meta_description: Dieser Betrag ist der erste in einer Reihe, der die Entwicklung
  eines Beispielbetriebssystems f√ºr meinen Kurs "Betriebssysteme" betrachtet. In diesem
  ersten Beitrag werden Motivation, Designziele und die Auswahl der Programmiersprache
  besprochen.
published: true
date: '2017-03-19 13:03:55 +0100'
tags:
- aihPOS
- Rust
- Raspberry Pi
categories:
- aihpos
---

**Inhalt**
- TOC
{:toc}
{% include next-previous-post-in-category %}
## Hintergrund

In meinem Kurs [Betriebssysteme][1] verwende ich ab und zu Code-Abschnitte, die die Implementation verschiedener Konzepte des Betriebssystementwurfs demonstrieren. Diese Code-Abschnitte sind bisher sehr uneinheitlich, und setzen sich aus verschiedenen Quellen zusammen:

  * Freier Code aus "echten" Betriebssystemen wie z.B. Linux;
  * "Unechter" Code (Code, zwar prinzipiell funktioniert, aber so nie einem Betriebsystem eingesetzt wurde), vornehmlich in C und Modula-2;
  * Pseudocode.

Um die Didaktik des Kurses zu verbessern, m√∂chte ich ein Betriebssystem extra f√ºr diese Veranstaltung schreiben, so dass m√∂glichst viele Konzepte direkt im Code wiederzufinden sind. Au√üerdem soll  **aihPOS** &#8212; so der Name des Projekts &#8212; sp√§ter als Codebasis bei verschiedenen Forschungsprojekten in unser Gruppe n√ºtzlich sein.

"aihPOS" steht f√ºr **a**nother **i**ncompatible and **h**ackneyed **P**i **O**perating **S**ystem. Obwohl dieses Akronym einiges √ºber das Betriebssystem
aussagt, habe ich es doch in erster Linie gew√§hlt, weil es r√ºckw√§rts geschrieben den Namen meiner Tochter ergibt: Sophia. Daher werde ich den Betriebssystemnamen ab sofort
so schreiben: SOPHIA. üôÇ 

## Ziele

Bevor man ein Projekt der Gr√∂√üe eines Betriebssystems beginnt, und sei es auch nur ein so kleines wie SOPHIA, muss man sich √ºber die Designziele im Klaren sein. Ich nenne
zun√§chst einmal einige Ziele, die ich ausdr√ºcklich **nicht** habe:

  * Geschwindigkeit: immer, wenn es einen Widerspruch zwischen **Performance** und einem klaren Design gibt, werde ich das klare Design bevorzugen. Schlie√ülich soll
    SOPHIA niemals produktiv eingesetzt werden, sondern zur Demonstrations- und Testzwecken dienen. 
  * **Kompatibilit√§t** zu POSIX, Windows o.√§.
  * Einsatz auf komplexer Hardware wie z.B. **x86**-PCs.

Vielmehr habe ich folgende Designziele:

  1. Wesentliche Konzepte von Betriebssystemen sollen entsprechende **Abstraktionen** im Code wiederfinden.
  2. Das Betriebssystem soll eine **klare Struktur** haben und dem **[Mikrokernel][2]**-Ansatz folgen.
  3. Als Zielhardware wird der **Raspberry Pi** benutzt. Er ist g√ºnstig zu haben, so dass Studierende leicht mit Modifikationen des Codes herumspielen k√∂nnen, ohne ihren
     teuren Laptop oder Desktop zu riskieren. Au√üerdem besitzt unser Labor bereits einen Klassensatz Raspberry Pi 1B+ (mit einer [Gertboard][3]-Erweiterung). 

## Sprache

Traditionell werden Betriebssysteme in Assembler oder C geschrieben. Theoretisch kann f√ºr das Schreiben von Betriebssysteme nahezu jede Sprache genutzt werden (und
z.T. werden sie auch tats√§chlich genutzt). H√§ufig muss zwar  "im Notfall" etwas Assembler-Code eingebunden werden (v√∂llig ohne geht es in der Regel sowieso
nicht, da viele Feinheiten der unterliegenden Maschine sich nicht in h√∂heren Programmiersprachen abbilden), aber es gibt Betriebssysteme in Java oder Lisp. Jedoch eignen
sich die meisten Sprachen nicht sonderlich gut f√ºr eine Bare-Metal-Entwicklung, wie ein Betriebssystem sie erfordert: Die Sprachen bringen ihr eigenes Laufzeitsystem mit,
das wiederum Systemrufe des Betriebssystem nutzt. Diese stehen aber bei der Entwicklung eines Betriebssystems ja gar nicht zur Verf√ºgung. Entsprechend k√∂nnen einige
Sprachkonzept nicht genutzt werden. Noch mehr Systemrufe sind meist in den Bibliotheken zu finden, so dass viele Bibliotheksfunktionen ebenfalls nicht genutzt werden
k√∂nnen und ggf. nachimplementiert werden m√ºssen. 

Trotzdem werde ich f√ºr SOPHIA **nicht** C benutzen, und das im wesentlichen aus drei Gr√ºnden:

  * Entsprechend der obigen Anforderungen sollen sich Betriebssystemkonzept gut in Code-Abstraktionen wiederfinden. Dies ist bei C fast so wenig der Fall, wie in Assembler.[^1]
  * C ist eine alte Sprache, die viele modernen Konzepte der [Typen- und Speicher- und Nebenl√§ufigkeitssicherheit][4] nicht kennt.  Daher ist das "Rumspielen" mit dem Code (vergleiche Designziel 3) relativ gef√§hrlich.
  * So ein Projekt ist immer eine gute Gelegenheit, eine neue Sprache zu erlernen (oder wenigstens zu vertiefen)

Es stellt sich die Frage, welche anderen Sprachen m√∂glich w√§ren. Die beiden derzeitigen Mainstream-Sprachen Java[^2] und Python kommen hier nicht infrage, da sie soweit
von der Maschine entfernt sind, dass die Br√ºcke zwischen Maschinen- und Sprachabstraktionen nicht sehr intuitiv w√§re. Es gibt in meiner Gruppe zwar ein Projekt, ein
Python-Betriebssystem zu schreiben, aber dies ist noch nicht so weit, dass es den hier gestellten Designzielen entspricht. 

Es gibt einige Sprachen, die f√ºr sich in Anspruch nehmen systemnahe zu sein. Die bekanntesten sind wohl C++, D, Forth, Go und Rust. Von diesen scheidet Forth aus, da es ein bi√üchen **zu** maschinennah ist. Au√üerdem werden Abstraktionen in der Regel auf Datenstrukturen abgebildet, wo Forth etwas limitiert ist. Die anderen vier Sprachen sind aus dieser Perspektive zweifellos alle geeignet.

Daher habe ich weitere Kriterien betrachtet, die sicherlich sowohl in Auswahl als auch Attribuierung z.T. etwas subjektiv sind:


|   | C++	| D	  | Go	|  Rust |
|:---:|:---:|:---:|:---:|:---:|
| Bare-metal Programmierung	| +	| 0 | ‚Äì | + |
| Speichersicherheit |	‚Äì[^3] |	+	| 0[^4] |+ |
| Nebenl√§ufigkeitssicherheit |	‚Äì | 0	| + |	+ |
| Toolstabilit√§t | + | ‚Äì	|  + | 0 |
| Subjektive Neuheit | 0 [^5] | ‚Äì | + | 0 |
    
   
Als Ergebnis dieser Betrachtungen werde ich SOPHIA in Rust schreiben. Mir erscheint auch Rust am meisten eine neue Sichtweise zu vermitteln.[^6] Es gibt ein bekanntes Zitat von [Alan J. Perlis][5]:
  
>  A language that doesn‚Äôt affect the way you think about programming is not worth knowing.
<cite>Alan J. Perlis</cite>
  
Dies ist der pers√∂nliche Hintergrund dieser Entscheidung. C++ mit etwas Programmierdisziplin h√§tte es genauso gut &#8212; und vermutlich an manchen Stellen einfacher &#8212; gemacht, aber Rust bringt mir neue Ideen bei.

## Betriebssystementwicklung

An dieser Stelle will ich nochmal auflisten, was bei der Betriebssystementwicklung anders ist, als bei der Entwicklung (vieler) anderer Software:

  * Man hat es nicht mit abstrakter, sondern konkreter Hardware zu tun. Dadurch muss man sich mit vielen technischen Details des Prozessors und der Gesamtplattform besch√§ftigen, die man sonst ignorieren kann.
  * Die Dienste eines Betriebssystems stehen nicht zur Verf√ºgung. Es gibt keine z.B. Speicherverwaltung und oder Dateisysteme. Daher stehen die meisten Funktionen der Standardbibliothek nicht zur Verf√ºgung, weil diese letztendlich Systemfunktionen rufen.
  * Durch die beiden obigen Umst√§nde werden im Design keine Abstraktionen "aufgezwungen". Sie m√ºssen erst erschaffen werden.
  * Damit ein Betriebssystem auch zum Laufen kommt, muss man sich Gedanken √ºber den Bootstrapping-Prozess und damit √ºber Bin√§rformate und die Toolchain machen.

In den kommenden Folgen dieser Serie werde ich beschreiben, wie dies mit Rust umgesetzt werden kann.

{% include alert text='<i>Ein Wort der **Warnung**: wie ich dargelegt habe, lerne ich Rust w√§hrend ich SOPHIA schreibe. Es ist also nicht zu erwarten, dass der Code
stilechter Rust-Code ist, eher wird vermutlich an vielen Stellen C/C++ durchscheinen.<br/><br/>Ich werde mich aber bem√ºhen und gegebenenfalls auch funktionierenden
Code sp√§ter √ºberarbeiten, um dem Geist von Rust n√§her zu kommen.<br/>Dies und die √úberarbeitungen von nightly Rust (siehe
<a href="/aihpos/2017/03/31/aihpos-ausrustung">n√§chster Beitrag</a>) werden dazu f√ºhren,
dass der Code alles andere als stabil sein wird. Aber das ist ja das generelle Abenteuer einer Software-Entwicklung.</i>' %}

## Dies sind die Abenteuer...
Diese Blog-Serie ist **nicht** als Tutorial zu verstehen[^8]. Es gibt auch keine Einf√ºhrung in die Rust- oder in die Assembler-Programmierung. Vielmehr werde ich einfach
darlegen, was mir beim Schreiben eines Betriebssystems in einer neuen Sprache "begegnet". Vielleicht werde ich sp√§ter, wenn SOPHIA einen gewissen Stand erreicht hat,
alles noch mal systematisieren und direkt f√ºr die Lehre aufarbeiten. Derzeit ist die Serie die Beschreibung einer Fahrt ins Ungewisse, mit m√∂glichen Sackgassen und der
Gefahr eines Schiffbruchs.

Das Abenteuer hat begonnen...

## N√ºtzliche Links

  * **Rust** 
      * [The Rust Programming Language][6] (the book)
      * [Rust Referenz][7]
      * [Rust Core Library][8]
      * [The Rustonomicon][9] ("Unsafe" Programmierung in Rust)
  * **ARM** 
      * [ARM1176JZF-S Technical Reference Manual &#8211; ARM Infocenter][10]
      * [ARM Systems Developer Guide][11] (etwas veraltet, aber trotzdem sehr hilfreich)
      * [ARM assembler in Raspberry Pi][12]
      * [Exploring ARM inline assembly in Rust][13]
  * **Raspberry Pi** 
      * [Seite der Raspberry Pi Foundation][14]
      * Broadcom: [BCM2835 ARM Peripherals][15]
      * David Welch: [Raspberry Pi ARM based bare metal examples][16]
  * **Betriebssystemprojekte in Rust** 
      * [Redox][17] &#8211; ein schon ziemlich ausgewachsenes UNIX-√§hnliches Betriebssystem (x86[^7])
      * [Ironkernel][18] (wohl erster BS-Ansatz in Rust, ARM)
      * Philipp Oppermann&#8217;s blog: [Writing an OS in Rust][19] (x86)
      * [IntermezzOS][20] (x86)

{% include next-previous-post-in-category %}

[^1]: Man kann schlie√ülich auch in den meisten Assemblern so etwas wie Structs definieren.
[^2]: Nein, ich habe Java nie ernsthaft in Betrachtung gezogen, was aber auch an meiner Abneigung gegen√ºber dieser Sprache liegen mag.
[^3]: Man kann in C++ sehr sicher schreiben, wenn man eine ausreichende Selbstdisziplin an den Tag legt und verschiedene Idiome nicht benutzt. Im Gegensatz dazu **erzwingt** z.B. Rust sicheren Code. Dort, wo man unsichere (weil m√§chtigere) Konstrukte braucht, muss es explizit gemacht werden. 
[^4]: Go bekommt in dieser Kategorie bei mir Punktabzug f√ºr den vorhandenen Null-Pointer
[^5]: Eigentlich wollte ich hier erst ein Minuszeichen setzen, habe es mir dann anders √ºberlegt: Ich habe C++ lange vor Boost und C++11 gelernt, und seitdem nie grundlegend "aufgeholt".
[^6]: Go landet da auf Platz 2, zumal ich schon mal in Occam reingeschnuppert hatte, und D erscheint mir z.T. bewu√üt "unoriginell" zu entworfen zu sein (was in einem anderem Kontext einen Vorteil darstellt).
[^7]: ARM ist geplant, aber bisher nur teilweise implementiert.
[^8]: Falls es jedoch Nachfragen gibt, bin ich aber gern bereit, auf einzelne Aspekte n√§her einzugehen. 

 [1]: http://osg.informatik.tu-chemnitz.de/lehre/os
 [2]: https://en.wikipedia.org/wiki/Microkernel
 [3]: https://www.gertbot.com
 [4]: http://joeduffyblog.com/2015/11/03/a-tale-of-three-safeties/
 [5]: https://de.wikipedia.org/wiki/Alan_J._Perlis
 [6]: https://doc.rust-lang.org/book/
 [7]: https://doc.rust-lang.org/reference/
 [8]: https://doc.rust-lang.org/core/index.html
 [9]: https://doc.rust-lang.org/nomicon/
 [10]: http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/ddi0301h_arm1176jzfs_r0p7_trm.pdf
 [11]: http://mazsola.iit.uni-miskolc.hu/~drdani/docs_arm/36_Elsevier-ARM_Sy.pdf
 [12]: http://thinkingeek.com/arm-assembler-raspberry-pi/
 [13]: http://embed.rs/articles/2016/arm-inline-assembly-rust/
 [14]: https://www.raspberrypi.org
 [15]: https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf
 [16]: https://github.com/dwelch67/raspberrypi
 [17]: https://www.redox-os.org
 [18]: https://github.com/wbthomason/ironkernel
 [19]: http://os.phil-opp.com
 [20]: http://intermezzos.github.io