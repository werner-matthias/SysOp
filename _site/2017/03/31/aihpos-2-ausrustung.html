<p>Nachdem im <a href="http://sysop.matthias-werner.net/aihpos-ein-betriebssystem-fuer-die-lehre-teil-1/">letzten Teil</a> die Design-Ziel von SOPHIA kurz diskutiert wurden, erläutert dieser Teil die Bereitstellung der Entwicklungswerkzeuge.</p>

<h1 id="setup-rust">Setup Rust</h1>

<p>Die Entwicklung von SOPHIA erfolgt nicht auf dem System, auf dem es später laufen soll — das gibt es ja noch gar nicht. Vielmehr soll die Entwicklung auf meinem Arbeitsplatzrechner stattfinden. Das ist in diesem Fall ein MacPro von 2010 mit MacOS. Irgendein Linux-Rechner würde auch gehen, zur Not sogar eine Windows-Maschine.1 Wir können also nicht den normalen Compiler benutzen, sondern einen Crosscompiler. Ein Crosscompiler wird auf einer Plattform ausgeführt (host), und erzeugt Code für eine andere Plattform (target). Ein „normaler“ Compiler ist also ein Crosscompiler, bei dem Host- und Targetplattform „zufällig“ identisch sind.</p>

<p>Glücklicherweise ist Rust — u.a. durch das  <a href="https://de.wikipedia.org/wiki/LLVM">LLVM-Backend</a>, das ja auch von clang benutzt wird — von vornherein als Crosscompiler ausgelegt. Etwas komplizierter ist, dass wir <em>bare metal</em> (also für eine Umgebung ohne Betriebssystem) entwickeln, aber dazu später. Installieren wir zunächst Rust. Dazu gibt es mehrere Wege, man kann den Paketmanager seiner Wahl benutzen. Die offiziell empfohlene Variante läuft über <code class="highlighter-rouge">rustup</code>. Um <code class="highlighter-rouge">rustup</code> selbst zu erhalten, sollte man in einer Shell</p>

<div class="highlighter-rouge"><pre class="highlight"><code>curl&amp;nbsp;https://sh.rustup.rs&amp;nbsp;-sSf&amp;nbsp;|&amp;nbsp;sh
</code></pre>
</div>

<p>eingeben und den Anweisungen folgen und zunächst die </p>

<p>_default-_Installation wählen. <code class="highlighter-rouge">rustup</code> installiert neben dem eigentlichen Compiler die Standardbibliotheken, das Build-Tool <code class="highlighter-rouge">cargo</code>, sowie Dokumentationen.</p>

<p>Wir werden jedoch für die Betriebssystementwicklung auch Inline-Assembler, Language Items2 und vielleicht einige andere Features brauchen, die noch nicht stabil sind und deshalb noch keinen Eingang in die stabile Version von Rust gefunden haben. Jedoch gibt es die sogenannte Nightly-Version von Rust, die diese Features hat, die wir zusätzlich installieren.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> rustup&amp;nbsp;install&amp;nbsp;nightly
</code></pre>
</div>

<p>Eine der netten Eigenschaften von Rust ist es, dass verschiedene Versionen und Toolchains sehr feingranular gemanagt werden können und sich nicht in die Quere kommen. Für jedes Projekt (und sogar Subprojekt) können wir jetzt auswählen, ob wir mit der stabilen oder der nightly Version arbeiten wollen. Wir wählen allerdings die nightly-Version als unsere Standardversion.</p>

<div class="highlighter-rouge"><pre class="highlight"><code> rustup&amp;nbsp;default&amp;nbsp;nightly
</code></pre>
</div>

<h1 id="targets">Targets</h1>

<p>Nach fertiger Installation können wir uns mögliche Targets anzeigen lassen:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rustup&amp;nbsp;target&amp;nbsp;list
  
  
  
aarch64-apple-ios
  
  
  
aarch64-linux-android
  
  
  
aarch64-unknown-fuchsia
  
  
  
aarch64-unknown-linux-gnu
  
  
  
arm-linux-androideabi
  
  
  
arm-unknown-linux-gnueabi
  
  
  
arm-unknown-linux-gnueabihf
  
  
  
arm-unknown-linux-musleabi
  
  
  
arm-unknown-linux-musleabihf
  
  
  
armv7-apple-ios
  
  
  
armv7-linux-androideabi
  
  
  
armv7-unknown-linux-gnueabihf
  
  
  
armv7-unknown-linux-musleabihf
  
  
  
armv7s-apple-ios
  
  
  
asmjs-unknown-emscripten
  
  
  
i386-apple-ios
  
  
  
i586-pc-windows-msvc
  
  
  
i586-unknown-linux-gnu
  
  
  
i686-apple-darwin
  
  
  
i686-linux-android
  
  
  
i686-pc-windows-gnu
  
  
  
i686-pc-windows-msvc
  
  
  
i686-unknown-freebsd
  
  
  
i686-unknown-linux-gnu
  
  
  
i686-unknown-linux-musl
  
  
  
mips-unknown-linux-gnu
  
  
  
mips-unknown-linux-musl
  
  
  
mips64-unknown-linux-gnuabi64
  
  
  
mips64el-unknown-linux-gnuabi64
  
  
  
mipsel-unknown-linux-gnu
  
  
  
mipsel-unknown-linux-musl
  
  
  
powerpc-unknown-linux-gnu
  
  
  
powerpc64-unknown-linux-gnu
  
  
  
powerpc64le-unknown-linux-gnu
  
  
  
s390x-unknown-linux-gnu
  
  
  
sparc64-unknown-linux-gnu
  
  
  
wasm32-unknown-emscripten
  
  
  
x86_64-apple-darwin&amp;nbsp;(default)
  
  
  
x86_64-apple-ios
  
  
  
x86_64-pc-windows-gnu
  
  
  
x86_64-pc-windows-msvc
  
  
  
x86_64-rumprun-netbsd
  
  
  
x86_64-unknown-freebsd
  
  
  
x86_64-unknown-fuchsia
  
  
  
x86_64-unknown-linux-gnu
  
  
  
x86_64-unknown-linux-musl
  
  
  
x86_64-unknown-netbsd
</code></pre>
</div>

<p>Eine Kombination wie  <code class="highlighter-rouge">x86_64-apple-darwin</code> nennt man das <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Target-Triple</a>, auch wenn diese Bezeichnung mitunter etwas irreführend anmutet, da das Target-Triple auch mehr (oder weniger) als drei Parameter haben kann. Die generische Form ist <code class="highlighter-rouge">---</code>. Betrachten wir das für uns notwendige Target-Triple genauer.</p>

<h2 id="architektur">Architektur</h2>

<p>Unter Architektur/Subarchitektur wird der Prozessor angegeben, und ggf. noch weitere Informationen wie die Endianess.</p>

<p>Unser Zielsystem, ein Raspberry Pi B+, hat einen ARM1176JZF-S-Prozessor und gehört damit zur ARM11-Familie, was wiederum eine ARMv6-Architektur impliziert. Der ARM1176JZF-S kennt drei verschiedene Befehlssätze, zwischen denen man umschalten kann:</p>

<ul>
  <li>den 32-Bit-ARM-Befehlssatz</li>
  <li>den 16-Bit-Thumb2-Befehlssatz</li>
  <li>den 8-Bit-Jazelle-Bytecode-Befehlssatz</li>
</ul>

<p>Die Bitzahl steht hier nicht für die Adressbreite, sondern für die Größe eines Befehls. Da die Dokumentation zum Jazelle-Befehlssatz nicht ohne weiteres öffentlich zugänglich ist, bleibt für uns die Auswahl zwischen ARM- und Thumb-Befehlssatz. Der Raspberry Pi B+ hat 512 MB Speicher, das ist für die heutigen Verhältnisse nicht sonderlich viel.3 Daher wäre die Nutzung des Thumb-Befehlssatzes eine gute Idee, da hier jeder Befehl nur die Hälfte des Speichers verbraucht.4 Da hier weniger Register und Befehle zur Verfügung stehen, braucht man wiederum für den gleichen Code mehr Befehle, aber erfahrungsgemäß ist die Speichereinsparung trotzdem um die 30%. Vergessen wir also den ARM-Befehlssatz und schreiben SOPHIA vollständig in Thumb? Nein, die Sache hat einen Haken: Jeder Ausnahmemode (Interruptmodi, Kernelmode, etc.) wird <em>immer</em> in ARM-Befehlsatz ausgeführt. Mit anderen Worten: Mindestens für den Kern sind wir auf den ARM-Befehlssatz angewiesen. Nutzerprogramme und Betriebssystemserver können dagegen mitunter in Thumb geschrieben werden.</p>

<p>Wenn man sich die obige Liste von Target-Triplen anschaut, dann fällt auf, dass es zwar armv7,- aber keine armv6-Einträge gibt. Die Einträge, die nur mit „arm“ anfangen, sind eigentlich für alle 32-Bit-ARM, d.h. auch ARMv7. Allerdings kann ARMv7 noch mehr, und ist nicht vollständig abwärtskompatibel.5</p>

<p>Die Angabe eines Herstellers ist optional. Er wird in unserem Fall ausgelassen oder erhält den Wert „unknown“.</p>

<h2 id="betriebssystem-und-binärschnittstelle">Betriebssystem und Binärschnittstelle</h2>

<p>Was das Betriebssystem angeht, so ist die Sache einfach: wir haben keines. Durch die Angabe des Betriebssystems weiß der Compiler, welche Systemrufe möglich sind. Dazu wird z.T. die genutzte Standardbibliothek auf dem System angegeben, gegen die gelenkt wird. So benennt „i686-unknown-linux-gnu“ die <a href="https://en.wikipedia.org/wiki/GNU_C_Library">GNU C Library</a>, während „i686-unknown-linux-musl“ die auf statisches Linken optimierte <a href="http://www.musl-libc.org">musl libc</a>.</p>

<p>Die Binärschnittstelle beschreibt, wie z.B. die Parameterübergabe bei Funktionsrufen erfolgt. Theoretisch  könnten wir uns hier auch unsere eigenen Konventionen ausdenken; es empfiehlt sich aber, an das den EABI-Standard  (<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0036b/IHI0036B_bsabi.pdf"><em>embedded-application binary interface</em></a>) zu halten, der für verschiedene Architekturen nicht nur die Aufrufkonventionen festlegt, sondern auch noch z.B. Dateiformate. Für ARM unterscheidet man noch durch einen Suffix („hf“) zur ABI, ob Gleitkommaoperationen durch einen (On-Chip-)Coprozessor ausgeführt werden sollen. Da ein Kernel i.d.R. keine Gleitkomma-Operationen ausführen muss, ist das eigentlich uninteressant. Da aber der Raspberry den VFPv2-Gleitkomma-Prozessor enthält, kann diese Option ruhig gewählt werden.</p>

<h1 id="ein-eigenes-target">Ein eigenes Target</h1>

<h2 id="architekturbeschreibung">Architekturbeschreibung</h2>

<p>Nach der Diskussion im letzten Abschnitt bräuchten wird also das Target-Triple <strong>arm-none-eabihf</strong> (und ggf. später <strong>arm-aihpos-eabihf</strong> und/oder<strong> </strong><strong>thumpv6-aihpos-eabihf</strong>). Leider gibt es dieses Triple (noch) nicht. Deshalb müssen wir eine Beschreibung dafür anlegen.6 Die Beschreibung ist eine JSON-Datei, und würde in unserem Fall etwa so aussehen:</p>

<p>{
 “llvm-target”: “arm-none-eabihf”,
 “target-endian”: “little”,
 “target-pointer-width”: “32”,
 “os”: “none”,
 “env”: “eabihf”,
 “vendor”: “unknown”,
 “arch”: “arm”,</p>

<p>“linker”: “arm-none-eabi-gcc”,
 “linker-flavor”: “gnu”,
 “data-layout”: “e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64”,
 “executables”: true,
 “relocation-model”: “static”,
 “no-compiler-rt”: true
}</p>

<p>Die meisten Punkte sollten selbsterklärend sein, außer wahrscheinlich „data-layout“. Hier werden Eigenschaften des Datenlayouts7, insbesondere Alignment in kompakter Form dargestellt, wobei einiges redundant zu den anderen Punkten ist:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>      e: little endiang
    
    
      m:e: ELF-Mangling, private Symbole erhalten einen .L-Prefix
    
    
      p:32:32: Größe und Alignment für Pointer, hier jeweils 32 Bit
    
    
      v128:64:128: Für 128-Bit-Vektoren ist das Alignment 64 Bit, bevorzugt 128 Bit
    
    
      a:0:32: Kein Alignment für Aggregattypen (wie struct), aber 32 Bit bevorzugt
    
    
      n32: Native Größe eines Integer ist 32 Bit
    
    
      S64: Stack hat Alignment von 64 Bit
</code></pre>
</div>

<h2 id="linker">Linker</h2>

<p>Dieses JSON-File kopieren wir in unser Projektverzeichnis, wir werden es später ständig brauchen. In ihm haben wir auch spezifiziert, dass für das Linken der GCC-Arm-Cross-Linker benutzt werden soll. Diesen müssen wir installieren, genau genommen die ganze Suite von GCC-Arm-Cross-Tools, wozu z.B. auch <code class="highlighter-rouge">arm-none-eabi-objcopy</code> oder <code class="highlighter-rouge">arm-none-eabi-readelf</code> gehört. Ich installiere die Tools über den bei mir vorhandenen Paketmanager <code class="highlighter-rouge">brew</code>, YMMV:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>brew&amp;nbsp;tap&amp;nbsp;nitsky/stm32
  
  
  
brew&amp;nbsp;install&amp;nbsp;arm-none-eabi-gcc
</code></pre>
</div>

<h2 id="core">Core</h2>

<p>Wie schon mehrmals betont, müssen wir auf den Einsatz der Rust-Standard-Bibliothek verzichten. Damit man aber nicht ganz auf dem Trockenen sitzt, hat Rust seine Standard-Bibliothek so strukturiert, dass es einen Teil gibt, der frei von externen Referenzen und Betriebssystemrufen ist: <code class="highlighter-rouge">core</code>. Aber natürlich gibt es core nicht nicht für unser Taget-Triple, daher müssen wir uns die Bibliothek selbst übersetzen. Dazu holen wir uns den Quellcode in unser Projektverzeichnis:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd&amp;nbsp;~/aihpos
  
  
  
git&amp;nbsp;clone&amp;nbsp;https://github.com/hackndev/rust-libcore
</code></pre>
</div>

<p>Jetzt können wir die Core-Bibliothek übersetzen. Dazu schreiben wir das Target-JSON-File in das Hauptverzeichnis der Core-Quellfiles und starten die Übersetzung mit</p>

<p><code class="highlighter-rouge">cargo</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd&amp;nbsp;rust-libcore
  
  
  
cp&amp;nbsp;../arm-none-eapihf.json&amp;nbsp;.
  
  
  
cargo&amp;nbsp;build&amp;nbsp;--release&amp;nbsp;--target=arm-none-eapihf
  
  
  
Compiling&amp;nbsp;rust-libcore&amp;nbsp;v0.0.3&amp;nbsp;(file:///Users/mwerner/aihpos/rust-libcore)
  
  
  
Finished&amp;nbsp;release&amp;nbsp;[optimized]&amp;nbsp;target(s)&amp;nbsp;in&amp;nbsp;47.20&amp;nbsp;secs
</code></pre>
</div>

<p>Unter rust-libcore/target/arm-none-eabihf/release finden wir die fertige Bibliothek libcore.rlib.</p>

<h1 id="debugger">Debugger</h1>

<p>Haben wir damit alles zusammen? Für die eigentliche Entwicklung schon. Aber ich möchte es mir etwas bequemer machen und nicht ständig die SD-Karte wechseln müssen. Glücklicherweise hat unserer Prozessor den Coprozessor CP14. Dieser ermöglicht die Nutzung eines <a href="https://en.wikipedia.org/wiki/JTAG">JTAG-Interfaces</a> zum Debuggen. Früher war JTAG-Hardware sehr teuer, die Preise kamen schnell in den vierstelligen Euro-Bereich. Das hat sich zum Glück geändert. Ich nutze den <a href="https://www.segger.com/j-link-edu.html">j-link EDU</a> der Firma Segger, den man (als Universität) bereits für knapp 60 € erwerben kann. Mein Freund und Kollege Jan Richling hat mir noch einen Adapter zur Verfügung gestellt, den er für sein Raspberry-Pi2-Praktikum einsetzt. Jedoch weisen der Raspberry 1B+ und der 2 bzgl. JTAG keine Unterschiede auf, so dass ich den Adapter auch für meinen Pi einsetzen kann.</p>

<p><a href="http://sysop.matthias-werner.net/wp-content/uploads/2017/04/jlink.png"></a>  <a href="http://sysop.matthias-werner.net/wp-content/uploads/2017/04/adapter.png"></a></p>

<p>Um diese Hardware nutzen zu können, brauche ich das Software-Gegenstück in Form des <a href="http://openocd.org">OpenOCD</a> (Open On-Chip Debugger). Die Installation übernimmt wieder <code class="highlighter-rouge">brew</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>brew&amp;nbsp;install&amp;nbsp;openocd
  



  
  
  
  

  Die Entwickler-Tools, die wir gleich besprechen, sind i.d.R. eher auf unixoide Systeme ausgerichtet, so dass es bei Windows meist etwas Mehraufwand gibt. &amp;#8629;


  Damit können Funktionen zur Verfügung gestellt werden, die sonst die in der Standardbibliothek sind, aber refactor zur Rust-Runtime gehören. &amp;#8629;


  Zum Vergleich: Ich war in meiner Jugend sehr stolz, dass ich den Speicher meines ersten Computers &amp;#8212; einen ZX 81 &amp;#8212; mit 64 kB(!) sehr weit ausgebaut hatte. &amp;#8629;


  Genau genommen nur die meisten, da es seit Thumb2 einige 32-Bit-Ausnahmen gibt. &amp;#8629;


  Der Raspberry 3 hat mit einem ARMv8-Prozessor einen noch anderen Befehlssatz, der hier aber nicht weiter betrachtet wird. &amp;#8629;


  Eine häufig genutzte Alternative wäre, &amp;#8222;arm-unknown-linux-gnueabihf&amp;#8220; oder &amp;#8222;arm-unknown-linux-musleabihf&amp;#8220; zu nehmen und ein paar Basisfunktionen der C-Bibliothek wie z.B. memcpy nachzuimplementieren. &amp;#8629;


  Eine genauere Beschreibung von möglichen Layout-Eigenschaften findet sich in der LLVM-Dokumentation &amp;#8629;
</code></pre>
</div>

