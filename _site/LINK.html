<!doctype html>
<html class="no-js" lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Seitenweise</title>
	<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive.css" />
	<script src="http://localhost:4000/assets/js/modernizr.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
      }
    });
  </script>

  <noscript>
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css' />
  </noscript>

  
	
	<meta name="description" content="Matthias Werners Blog. " />

	

	



	
	<link rel="icon" sizes="32x32" href="http://localhost:4000/assets/img/favicon-32x32.png" />




	
	<link rel="icon" sizes="192x192" href="http://localhost:4000/assets/img/touch-icon-192x192.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="http://localhost:4000/assets/img/apple-touch-icon-180x180-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="http://localhost:4000/assets/img/apple-touch-icon-152x152-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/assets/img/apple-touch-icon-144x144-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="http://localhost:4000/assets/img/apple-touch-icon-120x120-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/assets/img/apple-touch-icon-114x114-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="http://localhost:4000/assets/img/apple-touch-icon-76x76-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/assets/img/apple-touch-icon-72x72-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/assets/img/apple-touch-icon-precomposed.png" />	




	
	<meta name="msapplication-TileImage" content="http://localhost:4000/assets/img/msapplication_tileimage.png" />




	
	<meta name="msapplication-TileColor" content="#fabb00" />



	<!-- Facebook Optimization -->
	<meta property="og:locale" content="en_EN" />
	
	<meta property="og:title" content="Seitenweise" />
	<meta property="og:description" content="Matthias Werners Blog. " />
	<meta property="og:url" content="http://localhost:4000//LINK" />
	<meta property="og:site_name" content="Systems Operational" />
	

	

	<!-- Search Engine Optimization -->
	

	<link type="text/plain" rel="author" href="http://localhost:4000/humans.txt" />

	

	
</head>
   <script type="text/javascript"
      src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   </script>
</head>
<body id="top-of-page" class="page-fullwidth">
	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="http://localhost:4000" class="icon-tree"> Systems Operational</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        

              

          
          
        

              

          
          
        

              

          
          
        

              

          
          
            
            
              <li class="divider"></li>
              <li><a href="http://localhost:4000/about/">Über mich</a></li>

            
            
          
        
        
      </ul>

      <ul class="left">
        

              

          
          

            
            
              <li><a href="http://localhost:4000/">Start</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          

            
            

              <li class="has-dropdown">
                <a href="http://localhost:4000/blog/">Blog</a>

                  <ul class="dropdown">
                    

                      

                      <li><a href="http://localhost:4000/blog/archive/">Archive</a></li>
                    
                  </ul>
                  
              </li>
              <li class="divider"></li>
            
          
        

              

          
          

            
            
              <li><a href="http://localhost:4000/blog/aihpos/">aihPos</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead-no-image-header">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="http://localhost:4000" title="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
				<img src="http://localhost:4000/assets/img/logo.png" alt="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->









	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Ein Betriebssystem für die Lehre</p>
				<h1>Seitenweise</h1>
			</header>

			

			<span itemprop="articleSection">
	                <p><strong>Inhalt</strong></p>
<ul id="markdown-toc">
  <li><a href="#nach-mehr-aufgaben" id="markdown-toc-nach-mehr-aufgaben">Nach mehr Aufgaben</a></li>
  <li><a href="#paging-auf-dem-arm" id="markdown-toc-paging-auf-dem-arm">Paging auf dem ARM</a>    <ul>
      <li><a href="#tabellen" id="markdown-toc-tabellen">Tabellen</a></li>
      <li><a href="#zugriff" id="markdown-toc-zugriff">Zugriff</a></li>
      <li><a href="#rechte-und-typen" id="markdown-toc-rechte-und-typen">Rechte und Typen</a></li>
    </ul>
  </li>
  <li><a href="#implementierung" id="markdown-toc-implementierung">Implementierung</a>    <ul>
      <li><a href="#designentscheidungen" id="markdown-toc-designentscheidungen">Designentscheidungen</a></li>
      <li><a href="#datenstrukturen" id="markdown-toc-datenstrukturen">Datenstrukturen</a>        <ul>
          <li><a href="#tabelleneinträge" id="markdown-toc-tabelleneinträge">Tabelleneinträge</a></li>
          <li><a href="#tabellen-1" id="markdown-toc-tabellen-1">Tabellen</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><a class="left button tiny radius" href="http://localhost:4000/aihpos/2017/06/07/aihpos-heap/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="http://localhost:4000/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<h2 id="nach-mehr-aufgaben">Nach mehr Aufgaben</h2>
<p>Wie wir im <a href="/aihpos/2017/06/07/aihpos-heap/">vorherigen Beitrag</a>
diskutiert haben, hat die Speicherverwaltung in einem Betriebssystem
häufig noch zwei zusätzliche Aufgaben jenseits der reinen Zuteilung:</p>

<ul>
  <li>Prozesse sollen davor geschützt werden, dass sie sich gegenseitig in
den Speicher schreiben können;</li>
  <li>Es soll mehr Speicher genutzt werden können, als real zur Verfügung
 steht.</li>
</ul>

<p>Beides wird in der Regel mit dem gleichen Ansatz realisiert: <em>gestreute
Adressierung mit Paging</em><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. Wir wollen zunächst in <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> nur die
erste Aufgabe erfüllen.</p>

<h2 id="paging-auf-dem-arm">Paging auf dem ARM</h2>
<h3 id="tabellen">Tabellen</h3>
<p>Das Paging auf unserem Prozessor<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> erfolgt – wenn es den angeschaltet
ist – ein- bis -zweistufig. Das Top-Level-Verzeichnis kann den
vollständigen adressierbaren Speicherbereich organisieren, das sind
bei einer Adressbreite von 32 Bit 4 GiB. In diesem Verzeichnis gibt es
1024 Einträge zu je 4 Byte, so dass das gesamte Verzeichnis 4 kiB groß
ist und jeder für Eintrag 1 MiB steht. Ein solcher Eintrag kann
verschiedene Dinge enthalten:</p>

<ul>
  <li>Seitenfehler (<em>page fault</em>): Der Zugriff auf diesen Speicher führt
zu einer Ausnahme (<em>abort</em>);</li>
  <li><em>Section</em>: Ein Speicherbereich von 1 MiB Größe;</li>
  <li>Verweis auf eine Seitentabelle, die ebenfalls einen
  Speicherbereich von 1 MiB Größe beschreibt, jedoch eine feinere
  Unterteilung zulässt.</li>
</ul>

<p>Darüber hinaus gibt noch die sogenannte <em>Supersection</em>: einen
Speicherbereich von 16 MiB Größe. Wer jetzt aber glaubt, damit könnte
man das Top-Level-Verzeichnis kleiner machen, irrt sich: wenn
Supersections genutzt werden, muss jeder entsprechende Eintrag 16 mal
im Verzeichnis vorhanden sein. In <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> werden wir Supersections
nicht nutzen.</p>

<p>Um eine Verwechslung auszuschließen, wird im Folgenden das
Top-Level-Verzeichnis als <strong>Seitenverzeichnis</strong> (<em>page directory</em>) und
die Verzeichnisse der zweiten Stufe als <strong>Seitentabellen</strong> (<em>page
tables</em>) bezeichnet. Diese Namen sind häufig im Gebrauch, kommen aber
in der ARM-Dokumentation nicht vor: dort wird nut von <em>first level
table</em> und <em>second level tables</em> gesprochen.</p>

<p>Ein Seitentabelle ist 1 kiB groß und enthält 256 Einträge. Jeder der
Einträge kann wieder von unterschiedlicher Art sein:</p>

<ul>
  <li>Seitenfehler (hatten wir ja schon)</li>
  <li>große Speicherseite mit 64 kiB</li>
  <li>kleine Speicherseite mit 4 kiB</li>
</ul>

<p>Wieder gilt, dass eine goße Speicherseite 16 gleichlautende Einträge
in der Seitentabelle braucht. Durch Nutzung von großen Speicherseiten
kann also nicht an Platz für die Seitentabelle gespart werden.
In <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> werden wir vorerst kleine Speicherseiten nutzen.</p>

<h3 id="zugriff">Zugriff</h3>
<p>Bei einem Speicherzugriff auf die (gültige) logische Speicheradresse
<var>adr</var> bei eingeschalteten Paging und zweistufiger Hierarchie
geschieht Folgendes:</p>
<ol>
  <li>Aus dem Register <kbd>TTBR0</kbd> wird die Adresse des
Seitenverzeichnisses<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> geholt</li>
  <li>Die oberen 12 Bit von <var>adr</var> (also Bit 20 bis Bit 31)
dienen als Index im Speicherverzeichnis.</li>
  <li>Die oberen 12 Bits des dort gefundene 32-Bit-Wortes bilden die
oberen 12 Bits der Adresse der Seitentabelle, die unteren sind 0.</li>
  <li>Die nächsten 8 Bit von <var>adr</var> (Bits 12 bis Bit 19) sind der
 Index in dieser Seitentabelle.</li>
  <li>Von dem gefundenen Wort werden die oberen 20 Bit (Bit 12 bis Bit
 31) genommen und daran die unteren 12 Bit (Bit 0 bis Bit 11)
 angehangen. Dieses zusammengesetzt Wort ist die physische Adresse,
 (Busadresse) auf die tatäsächlich zugegriffen wird.</li>
</ol>

<p>Die Abbildung zeigt diesen „Tabellenlauf“ (<em>table walk</em>) noch einmal
im Zusammenhang.</p>

<p><img src="https://werner-matthias.github.io/SysOp/images/paging.png" alt="" class="img-responsive" /></p>

<p>Damit nicht durch die ständigen Speicherzugriffe viel Zeit verloren
geht, hat der ARM mehrere Caches, darunter einen
<a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a> .</p>

<h3 id="rechte-und-typen">Rechte und Typen</h3>
<p>Die übrig gebliebenen Bits im Seitenverzeichnis und in der
Seitentabelle haben auch Aufgaben. Einerseits geben sie an, welches
Speicherkonsistenzmodell und damit welche Cachestrategie benutzt
werden soll. So ist es z.B. wichtig zu wissen, ob es einen geteilten
(<em>shared</em>) Zugriff auf eine Speicherseite gibt.</p>

<p>Andererseits, werden Reche angegeben, also wann und wie auf eine Seite
zugegriffen werden darf:</p>
<ul>
  <li>ob lesend+schreibend, nur schreibend, oder gar nicht;</li>
  <li>ob in einem privilegierten und/oder im nichtpriviligierten Modus;</li>
  <li>ob die Seite ausführbaren Code enthalten darf.</li>
</ul>

<p>Darüber hinaus gehört jede Seitentabelle einer <em>Domain</em> an. Davon kann
es bis zu 16 geben, von denen zu jedem Zeitpunkte eine oder mehrere
aktiv sein können. Ist eine Domain nicht aktiv, so führt ein Zugriff
auf einen entsprechenden Speicher automatisch zu einem Zugriffsfehler,
unabhängig von den Rechten in der Seitentabelle. Auf diese Weise
können z.B. bei einem Prozesswechesel Teile des Speichers gesperrt
werden, ohne das Seitenverzeichnis zu verändern.</p>

<h2 id="implementierung">Implementierung</h2>
<h3 id="designentscheidungen">Designentscheidungen</h3>

<p>Bevor wir an die Nutzung der Paging-Hardware machen, müssen uns
Gedanken über das  Speicherlayout machen. Dazu müssen wir einige
Aspekte berücksichtigen:</p>
<ul>
  <li>Da der Zugriff auf das Seitenverzeichnis und die Seitentabellen
selbst von der Adressübersetzung betroffen sind, wird es
unkomplizierter, wenn die Speicherbereiche in denen sie sich
befinden auf sich selbst abgebildert werden.</li>
  <li>Auch für den Kernel-Code ist es einfacher, wenn er in einem auf sich
selbst abgebildeten Adressbereich liegt.</li>
  <li>Die (Speicher-)Größe eines Prozesses bestimmt, wieviele
Seitentabellen wir für ihn benötigen. Der Einfachheit halber legen
wir fest, dass kein Prozess größer als 1 MiB ist, was für alle Fälle
<a href="https://de.wikiquote.org/wiki/Bill_Gates">reichen sollte</a>. Damit
brauchen wir jedem Prozess später nur eine Seitentabelle zuordnen.
 Zusammen mit der Entscheidung vom <a href="/aihpos/2017/06/07/aihpos-heap/">letzen Beitrag</a>, die Stacks ans Ende des verfügbaren RAM
zu legen, ergibt sich aus Kernel-Sicht folgendes Speicherlayout:</li>
</ul>

<p><img src="https://werner-matthias.github.io/SysOp/images/memory-layout.png" alt="" class="img-responsive" /></p>

<p>Alle Prozesse sollen logisch den gleichen Adressbereich haben. Wir legen
fest, dass der maximal 1 MiB große Adressbereich von 0x02000000 bis
0x020FFFFF geht. Damit ist hinreichen Platz für den Kernel und seine
Verwaltungsdaten im unteren Bereich des Speichers. Für einen Prozess
sähe der Adressbereich dann ungefähr so aus, wobei die schwarz-gelb
schraffierten Gebiete „verboten“ sind, wo ein Speicherzugriff des
Prozesses also zu einer Ausnahme führt. Ob der Prozess auf den
Adressbereich mit den Geräten zugreifen darf, hängt von seinen Rechten
ab; bei Treiberprozessen sollte man einen entsprechenden Zugriff
natürlich gestatten.</p>

<p><img src="https://werner-matthias.github.io/SysOp/images/pmemory-layout.png" alt="" class="img-responsive" /></p>

<h3 id="datenstrukturen">Datenstrukturen</h3>
<p>Nachdem wir die Designentscheidungen getroffen haben, können die
Datenstrukturen festgelegt werden.</p>

<h4 id="tabelleneinträge">Tabelleneinträge</h4>
<p>Die einfachsten Datenstrukturen sind die Einträge in den
Seitentabellen bzw. dem Seitenvereichnis: Das in eigentlich nur
32-Bit-Worte, in Rust also <code class="highlighter-rouge">u32</code> (oder <code class="highlighter-rouge">usize</code>):</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">PageDirectoryEntry</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">PageTableEntry</span>     <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
</code></pre>
</div>
<p>In Rust wird damit nur ein Typenalias geschaffen, für den Typencheck
sind es also immer noch ein <code class="highlighter-rouge">u32</code>. Funktionen zum Manipulieren könnten
also nicht unterscheiden, ob sie ein Eintrag in eine Seitentabelle
oder in das Seitenverzeichnis bearbeiten, man hat also keine
Typensicherheit.
Andererseits können die skalaren Grundtypen von Rust nicht einfach so
erweitert werden, wir können also keine zusätzlichen <em>Methoden</em> für
<code class="highlighter-rouge">u32</code> schreiben.</p>

<p>Um trotzdem etwas Abstraktion und Typensicherheit zu erhalten, habe
ich für die Generierung der Tabelleneinträge das
<a href="https://doc.rust-lang.org/book/first-edition/method-syntax.html#builder-pattern"><em>Builder</em>-Muster</a>
ausgewählt, also eine <code class="highlighter-rouge">struc</code>, deren Methoden
verkettet werden können und die die gewünschte Datenstruktur erzeugt.</p>

<p>Die Einträge in das Seitenverzeichnis und in eine Seitentabelle haben
ähnliche Funktionen. In einer objektorientierten Sprache würde man
dies über ein Klassenkonzept oder ein Interface abbilden. In Rust
nimmt man zur Beschreibung gemeinsamen Verhaltens einen <em>Trait</em>:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// `MemoryBuilder` ist eine Builder-Struct für zur Erstellung von Einträgen</span>
<span class="c">///  in das Seitenverzeichnis oder in Seitentabellen</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">u32</span><span class="p">,</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">DirectoryEntry</span><span class="o">&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">DirectoryEntry</span><span class="o">&gt;</span><span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span>      <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span><span class="p">{}</span>

<span class="c">/// Einträge in das Seitenverzeichnis (_page directory_) und die Seitentabellen</span>
<span class="c">/// (_page table_) haben ähnliche Funktionalität. Daher haben sie einen Trait als</span>
<span class="c">/// gemeinsames Interface.</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">EntryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    
    <span class="c">/// Erzeugt einen neuen Eintrag </span>
    <span class="k">fn</span> <span class="nf">new_entry</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Gibt die Art des Eintrags</span>
    <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
    
    <span class="c">/// Setzt die Basisadresse</span>
    <span class="k">fn</span> <span class="nf">base_addr</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        
    <span class="c">/// Legt die Art des Speichers (Caching) fest</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `StronglyOrdered`  (_stikt geordnet_), siehe ARM DDI 6-15</span>
    <span class="k">fn</span> <span class="nf">mem_type</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">MemType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="c">/// Setzt die Zugriffsrechte</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: Kein Zugriff</span>
    <span class="k">fn</span> <span class="nf">rights</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">MemoryAccessRight</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, zu welcher Domain der Speicherbereich gehört</span>
    <span class="c">///</span>
    <span class="c">///   * Für Supersections und Seiten wird die Domain ignoriert</span>
    <span class="c">///   * Vorgabe: 0</span>
    <span class="k">fn</span> <span class="nf">domain</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt Speicherbereich als gemeinsam (_shared_) fest</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (nicht gemeinsam)</span>
    <span class="k">fn</span> <span class="nf">shared</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, ob ein Speicherbereich global (`false`) oder prozessspezifisch</span>
    <span class="c">/// ist. Bei prozessspezifischen Speicherbereichen wird die ASID aus dem</span>
    <span class="c">/// ContextID-Register (CP15c13) genutzt.</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (global)</span>
    <span class="c">///  * Anmerkung: aihPOS nutzt *keine* prozessspezifischen Speicherbereich</span>
    <span class="k">fn</span> <span class="nf">process_specific</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ps</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, ob Speicherinhalt als Code ausgeführt werden darf</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (ausführbar)</span>
    <span class="k">fn</span> <span class="nf">no_execute</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ne</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Gibt den Eintrag zurück</span>
    <span class="k">fn</span> <span class="nf">entry</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Für die Implementierung des Traits müssen jetzt nur die Bits nach
Handbuch gesetzt werden. Ich habe für die Bitmanipulation wieder
die <code class="highlighter-rouge">Bitfield</code>-Crate genutzt. Folgender Codeausschnitt zeigt
exemplarische die Implementation der Methode, die für einen
Seitentabelleneitrag festlegt, ob die entsprechende Speicherseite
ausführbaren Code enthalten darf:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code>    <span class="k">fn</span> <span class="nf">no_execute</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ne</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">TableEntry</span><span class="p">::</span><span class="n">LargePage</span> 
                <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="n">ne</span><span class="p">);</span> <span class="p">},</span>
            <span class="nn">TableEntry</span><span class="p">::</span><span class="n">SmallPage</span>
                <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ne</span><span class="p">);</span> <span class="p">},</span>
            <span class="n">_</span>   <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
        <span class="k">self</span>
    <span class="p">}</span>
</code></pre>
</div>
<p>Wenn dann ein Mapping – also eine Abbildung zwischen logischen und
physischen Adressen – festgelegt wird, werden einfach die Methoden
der Builder-struct verkettet, bis der gewünschte Eintrag
entstanden ist, wie folgdendes Beispiel aus dem Initalisierungscode
zeigt:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code>        <span class="n">kpage_table</span><span class="p">[</span><span class="n">frm</span><span class="nf">.rel</span><span class="p">()]</span> <span class="o">=</span> <span class="nn">MemoryBuilder</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new_entry</span><span class="p">(</span><span class="nn">TableEntry</span><span class="p">::</span><span class="n">SmallPage</span><span class="p">)</span>
            <span class="nf">.base_addr</span><span class="p">(</span><span class="n">frm</span><span class="nf">.start</span><span class="p">())</span>
            <span class="nf">.rights</span><span class="p">(</span><span class="nn">MemoryAccessRight</span><span class="p">::</span><span class="n">SysRwUsrNone</span><span class="p">)</span>
            <span class="nf">.mem_type</span><span class="p">(</span><span class="nn">MemType</span><span class="p">::</span><span class="n">NormalWT</span><span class="p">)</span>
            <span class="nf">.domain</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="nf">.entry</span><span class="p">();</span>
</code></pre>
</div>

<h4 id="tabellen-1">Tabellen</h4>
<p>Die Tabellen (Seitentabellen und Seitenverzeichnis) sind im
Endergebnis einfache Arrays. Um aber auch hier Typensicherheit zu
erhalten und das richtige Alignment zu erzwingen, werden diese Arrays
jeweils Elemente eines Verbundstyps (<code class="highlighter-rouge">struct</code>).
Damit man trotzdem wie auf ein Array zugreifen kann, also der
<code class="highlighter-rouge">[ ]</code>-Operator funktioniert, muss der <code class="highlighter-rouge">Index</code>- und der
<code class="highlighter-rouge">IndexMut</code>-Trait implementiert werden:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">ops</span><span class="p">::{</span><span class="nb">Index</span><span class="p">,</span> <span class="n">IndexMut</span><span class="p">};</span>

<span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="nn">builder</span><span class="p">::{</span><span class="n">PageTableEntry</span><span class="p">,</span><span class="n">TableEntry</span><span class="p">,</span><span class="n">MemoryBuilder</span><span class="p">,</span><span class="n">EntryBuilder</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="n">Address</span><span class="p">;</span>

<span class="cp">#[repr(C)]</span>
<span class="cp">#[repr(align(</span><span class="mi">1024</span><span class="cp">))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">PageTableEntry</span><span class="p">;</span><span class="mi">256</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="c">/// Erzeugt eine neue Tabelle</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span>  <span class="n">PageTable</span> <span class="p">{</span>
        <span class="n">PageTable</span> <span class="p">{</span>
            <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">256</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">/// Füllt die Tabelle mit Seitenfehlern</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">invalidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">ndx</span> <span class="n">in</span> <span class="mi">0</span><span class="err">..</span><span class="mi">256</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span> <span class="o">=</span> <span class="nn">MemoryBuilder</span><span class="p">::</span><span class="nf">new_entry</span><span class="p">(</span><span class="nn">TableEntry</span><span class="p">::</span><span class="n">Fault</span><span class="p">)</span><span class="nf">.entry</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">/// Addresse der Tabelle</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">addr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Address</span> <span class="p">{</span>
        <span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">PageTableEntry</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">PageTableEntry</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">IndexMut</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><a class="left button tiny radius" href="http://localhost:4000/aihpos/2017/06/07/aihpos-heap/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="http://localhost:4000/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Umgangssprachlich wird mit <em>Paging</em> fast immer <em>Demand Paging</em>,
    also die virtuelle Speicherverwaltung mit Auslagerung auf die
    Festplatte gemeint. Jedoch lässt sich eine seitenbasierte gestreute
    Adressierung auch sinnvoll ohne Auslagerung einsetzen.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Das hier beschriebene Paging-Schema entspricht ARMv6. Der
    Prozessor ist in einigen Aspekten der Sepiecherverwaltung
    rückwärtskompatible zu ARMv5 (z.B. Supbages), die wir nicht
    benutzen werden.&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Es gibt auch ein Schema mit zwei Seitenverzeichnissen, das hier
    aber nicht betrachtet wird.&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

	                </span>
			
						<div id="page-meta" class="t30">
				<p>
					<!-- Look the author details up from the site config. -->
					
					<!-- Output author details if some exist. -->
					
					<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name" class="pr20 icon-edit"><a href="http://osg.informatik.tu-chemnitz.de/Staff/M_Werner/index.php?lang=en" target="_blank"> Matthias Werner</a></span>
				</span>
				

				
				<time class="icon-calendar pr20" datetime="2017-06-18" itemprop="datePublished"> 2017-06-18</time>
				

				<span class="icon-archive pr20"> AIHPOS · COMPUTER</span>
				<br />
				<span class="pr20"><span class="icon-price-tag pr10"> Rust</span> <span class="icon-price-tag pr10"> aihpos</span> <span class="icon-price-tag pr10"> paging</span> </span>
			</p>

			<div id="post-nav" class="row">
				
				<div class="small-5 columns"><a class="button small radius prev" href="http://localhost:4000/aihpos/2017/06/07/aihpos-heap/">&laquo; Wir machen einen Haufen</a></div><!-- /.small-4.columns -->
				
				<div class="small-2 columns text-center"><a class="radius button small" href="http://localhost:4000/blog/archive/" title="Blog Archiv">Archiv</a></div><!-- /.small-4.columns -->
				
				<div class="small-5 columns text-right"><a class="button small radius next" href="http://localhost:4000/meta/2017/06/19/hello-jekyll/">Hello Jekyll &raquo;</a></div><!-- /.small-4.columns -->
				
			</div>
			</div><!--  /.page-meta -->
			

	                
		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">Über diese Website</h5>

            <p class="shadow-black">
              Matthias Werners Blog. 
              <a href="http://localhost:4000/info/">Mehr ›</a>
            </p>
          </div><!-- /.large-6.columns -->


          <div class="small-6 medium-3 large-3 large-offset-1 columns">
            
              
              <ul class="no-bullet shadow-black">
              
              </ul>
          </div><!-- /.large-4.columns -->


          <div class="small-6 medium-3 large-3 columns">
            
              
            <ul class="no-bullet shadow-black">
            
            </ul>
          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="http://localhost:4000/assets/js/javascript.min.js"></script>














</body>
</html>

