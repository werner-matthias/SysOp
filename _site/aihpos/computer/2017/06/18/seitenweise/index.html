<!doctype html>
<html class="no-js" lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Seitenweise</title>
	<link rel="stylesheet" type="text/css" href="https://werner-matthias.github.io/SysOp/assets/css/styles_feeling_responsive.css" />
	<script src="https://werner-matthias.github.io/SysOp/assets/js/modernizr.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
      }
    });
  </script>

  <noscript>
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css' />
  </noscript>

  
	
	<meta name="description" content="Die Programmierung der MMU ist eine heikle Angelegenheit. Machen wir uns an die Arbeit."/>

	

	



	
	<link rel="icon" sizes="32x32" href="https://werner-matthias.github.io/SysOp/assets/img/favicon-32x32.png" />




	
	<link rel="icon" sizes="192x192" href="https://werner-matthias.github.io/SysOp/assets/img/touch-icon-192x192.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-180x180-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-152x152-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-144x144-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-120x120-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-114x114-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-76x76-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-72x72-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-precomposed.png" />	




	
	<meta name="msapplication-TileImage" content="https://werner-matthias.github.io/SysOp/assets/img/msapplication_tileimage.png" />




	
	<meta name="msapplication-TileColor" content="#fabb00" />



	<!-- Facebook Optimization -->
	<meta property="og:locale" content="en_EN" />
	
	<meta property="og:title" content="Seitenweise" />
	<meta property="og:description" content="Die Programmierung der MMU ist eine heikle Angelegenheit. Machen wir uns an die Arbeit." />
	<meta property="og:url" content="https://werner-matthias.github.io/SysOp//aihpos/computer/2017/06/18/seitenweise/" />
	<meta property="og:site_name" content="Systems Operational" />
	

	

	<!-- Search Engine Optimization -->
	

	<link type="text/plain" rel="author" href="https://werner-matthias.github.io/SysOp/humans.txt" />

	

	
</head>
   <script type="text/javascript"
      src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   </script>
</head>
<body id="top-of-page" class="page-fullwidth">
	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="https://werner-matthias.github.io/SysOp" class="icon-tree"> Systems Operational</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        

              

          
          
        

              

          
          
        

              

          
          
        

              

          
          
            
            
              <li class="divider"></li>
              <li><a href="https://werner-matthias.github.io/SysOp/about/">Über mich</a></li>

            
            
          
        
        
      </ul>

      <ul class="left">
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/">Start</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          

            
            

              <li class="has-dropdown">
                <a href="https://werner-matthias.github.io/SysOp/blog/">Blog</a>

                  <ul class="dropdown">
                    

                      

                      <li><a href="https://werner-matthias.github.io/SysOp/blog/archive/">Archive</a></li>
                    
                  </ul>
                  
              </li>
              <li class="divider"></li>
            
          
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/blog/aihpos/">aihPos</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead-no-image-header">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="https://werner-matthias.github.io/SysOp" title="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
				<img src="https://werner-matthias.github.io/SysOp/assets/img/logo.png" alt="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->









	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Ein Betriebssystem für die Lehre</p>
				<h1>Seitenweise</h1>
			</header>

			

			<span itemprop="articleSection">
	                <p><strong>Inhalt</strong></p>
<ul id="markdown-toc">
  <li><a href="#nach-mehr-aufgaben" id="markdown-toc-nach-mehr-aufgaben">Nach mehr Aufgaben</a></li>
  <li><a href="#paging-auf-dem-arm" id="markdown-toc-paging-auf-dem-arm">Paging auf dem ARM</a>    <ul>
      <li><a href="#tabellen" id="markdown-toc-tabellen">Tabellen</a></li>
      <li><a href="#zugriff" id="markdown-toc-zugriff">Zugriff</a></li>
      <li><a href="#rechte-und-typen" id="markdown-toc-rechte-und-typen">Rechte und Typen</a></li>
    </ul>
  </li>
  <li><a href="#implementierung" id="markdown-toc-implementierung">Implementierung</a>    <ul>
      <li><a href="#designentscheidungen" id="markdown-toc-designentscheidungen">Designentscheidungen</a></li>
      <li><a href="#datenstrukturen" id="markdown-toc-datenstrukturen">Datenstrukturen</a>        <ul>
          <li><a href="#tabelleneinträge" id="markdown-toc-tabelleneinträge">Tabelleneinträge</a></li>
          <li><a href="#tabellen-1" id="markdown-toc-tabellen-1">Tabellen</a></li>
          <li><a href="#frames" id="markdown-toc-frames">Frames</a></li>
          <li><a href="#frame-manager" id="markdown-toc-frame-manager">Frame-Manager</a></li>
        </ul>
      </li>
      <li><a href="#in-die-niederungen" id="markdown-toc-in-die-niederungen">In die Niederungen</a></li>
    </ul>
  </li>
  <li><a href="#schlussbemerkung" id="markdown-toc-schlussbemerkung">Schlussbemerkung</a></li>
</ul>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/aihpos/2017/06/07/aihpos-heap/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="https://werner-matthias.github.io/SysOp/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<h2 id="nach-mehr-aufgaben">Nach mehr Aufgaben</h2>
<p>Wie wir im <a href="/aihpos/2017/06/07/aihpos-heap/">vorherigen Beitrag</a>
diskutiert haben, hat die Speicherverwaltung in einem Betriebssystem
häufig noch zwei zusätzliche Aufgaben jenseits der reinen Zuteilung:</p>

<ul>
  <li>Prozesse sollen davor geschützt werden, dass sie sich gegenseitig in
den Speicher schreiben können;</li>
  <li>Es soll mehr Speicher genutzt werden können, als real zur Verfügung
steht.</li>
</ul>

<p>Beides wird in der Regel mit dem gleichen Ansatz realisiert: <em>gestreute
Adressierung mit Paging</em><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. Wir wollen zunächst in <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/assets/img/sophia.png"> nur die
erste Aufgabe erfüllen.</p>

<h2 id="paging-auf-dem-arm">Paging auf dem ARM</h2>
<h3 id="tabellen">Tabellen</h3>
<p>Das Paging auf unserem Prozessor<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> erfolgt – wenn es den angeschaltet
ist – ein- bis -zweistufig. Das Top-Level-Verzeichnis kann den
vollständigen adressierbaren Speicherbereich organisieren, das sind
bei einer Adressbreite von 32 Bit 4 GiB. In diesem Verzeichnis gibt es
1024 Einträge zu je 4 Byte, so dass das gesamte Verzeichnis 4 kiB groß
ist und jeder für Eintrag 1 MiB steht. Ein solcher Eintrag kann
verschiedene Dinge enthalten:</p>

<ul>
  <li>Seitenfehler (<em>page fault</em>): Der Zugriff auf diesen Speicher führt
zu einer Ausnahme (<em>abort</em>);</li>
  <li><em>Section</em>: Ein Speicherbereich von 1 MiB Größe;</li>
  <li>Verweis auf eine Seitentabelle, die ebenfalls einen
  Speicherbereich von 1 MiB Größe beschreibt, jedoch eine feinere
  Unterteilung zulässt.</li>
</ul>

<p>Darüber hinaus gibt noch die sogenannte <em>Supersection</em>: einen
Speicherbereich von 16 MiB Größe. Wer jetzt aber glaubt, damit könnte
man das Top-Level-Verzeichnis kleiner machen, irrt sich: wenn
Supersections genutzt werden, muss jeder entsprechende Eintrag 16 mal
im Verzeichnis vorhanden sein. In <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/assets/img/sophia.png"> werden wir Supersections
nicht nutzen.</p>

<p>Um eine Verwechslung auszuschließen, wird im Folgenden das
Top-Level-Verzeichnis als <strong>Seitenverzeichnis</strong> (<em>page directory</em>) und
die Verzeichnisse der zweiten Stufe als <strong>Seitentabellen</strong> (<em>page
tables</em>) bezeichnet. Diese Namen sind häufig im Gebrauch, kommen aber
in der ARM-Dokumentation nicht vor: dort wird nut von <em>first level
table</em> und <em>second level tables</em> gesprochen.</p>

<p>Ein Seitentabelle ist 1 kiB groß und enthält 256 Einträge. Jeder der
Einträge kann wieder von unterschiedlicher Art sein:</p>

<ul>
  <li>Seitenfehler (hatten wir ja schon)</li>
  <li>große Speicherseite mit 64 kiB</li>
  <li>kleine Speicherseite mit 4 kiB</li>
</ul>

<p>Wieder gilt, dass eine goße Speicherseite 16 gleichlautende Einträge
in der Seitentabelle braucht. Durch Nutzung von großen Speicherseiten
kann also nicht an Platz für die Seitentabelle gespart werden.
In <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/assets/img/sophia.png"> werden wir vorerst kleine Speicherseiten nutzen.</p>

<h3 id="zugriff">Zugriff</h3>
<p>Bei einem Speicherzugriff auf die (gültige) logische Speicheradresse
<var>adr</var> bei eingeschalteten Paging und zweistufiger Hierarchie
geschieht Folgendes:</p>
<ol>
  <li>Aus dem Register <kbd>TTBR0</kbd> wird die Adresse des
Seitenverzeichnisses<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> geholt</li>
  <li>Die oberen 12 Bit von <var>adr</var> (also Bit 20 bis Bit 31)
dienen als Index im Speicherverzeichnis.</li>
  <li>Die oberen 12 Bits des dort gefundene 32-Bit-Wortes bilden die
oberen 12 Bits der Adresse der Seitentabelle, die unteren sind 0.</li>
  <li>Die nächsten 8 Bit von <var>adr</var> (Bits 12 bis Bit 19) sind der
 Index in dieser Seitentabelle.</li>
  <li>Von dem gefundenen Wort werden die oberen 20 Bit (Bit 12 bis Bit
 31) genommen und daran die unteren 12 Bit (Bit 0 bis Bit 11)
 angehangen. Dieses zusammengesetzt Wort ist die physische Adresse,
 (Busadresse) auf die tatäsächlich zugegriffen wird.</li>
</ol>

<p>Die Abbildung zeigt diesen „Tabellenlauf“ (<em>table walk</em>) noch einmal
im Zusammenhang.</p>

<p><img src="https://werner-matthias.github.io/SysOp/images/paging.png" alt="" class="img-responsive" /></p>

<p>Damit nicht durch die ständigen Speicherzugriffe viel Zeit verloren
geht, hat der ARM mehrere Caches, darunter einen
<a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a> .</p>

<h3 id="rechte-und-typen">Rechte und Typen</h3>
<p>Die übrig gebliebenen Bits im Seitenverzeichnis und in der
Seitentabelle haben auch Aufgaben. Einerseits geben sie an, welches
Speicherkonsistenzmodell und damit welche Cachestrategie benutzt
werden soll. So ist es z.B. wichtig zu wissen, ob es einen geteilten
(<em>shared</em>) Zugriff auf eine Speicherseite gibt.</p>

<p>Andererseits, werden Reche angegeben, also wann und wie auf eine Seite
zugegriffen werden darf:</p>
<ul>
  <li>ob lesend+schreibend, nur schreibend, oder gar nicht;</li>
  <li>ob in einem privilegierten und/oder im nichtpriviligierten Modus;</li>
  <li>ob die Seite ausführbaren Code enthalten darf.</li>
</ul>

<p>Darüber hinaus gehört jede Seitentabelle einer <em>Domain</em> an. Davon kann
es bis zu 16 geben, von denen zu jedem Zeitpunkte eine oder mehrere
aktiv sein können. Ist eine Domain nicht aktiv, so führt ein Zugriff
auf einen entsprechenden Speicher automatisch zu einem Zugriffsfehler,
unabhängig von den Rechten in der Seitentabelle. Auf diese Weise
können z.B. bei einem Prozesswechesel Teile des Speichers gesperrt
werden, ohne das Seitenverzeichnis zu verändern.</p>

<h2 id="implementierung">Implementierung</h2>
<h3 id="designentscheidungen">Designentscheidungen</h3>

<p>Bevor wir an die Nutzung der Paging-Hardware machen, müssen uns
Gedanken über das  Speicherlayout machen. Dazu müssen wir einige
Aspekte berücksichtigen:</p>
<ul>
  <li>Da der Zugriff auf das Seitenverzeichnis und die Seitentabellen
selbst von der Adressübersetzung betroffen sind, wird es
unkomplizierter, wenn die Speicherbereiche in denen sie sich
befinden auf sich selbst abgebildert werden.</li>
  <li>Auch für den Kernel-Code ist es einfacher, wenn er in einem auf sich
selbst abgebildeten Adressbereich liegt.</li>
  <li>Die (Speicher-)Größe eines Prozesses bestimmt, wieviele
Seitentabellen wir für ihn benötigen. Der Einfachheit halber legen
wir fest, dass kein Prozess größer als 1 MiB ist, was für alle Fälle
<a href="https://de.wikiquote.org/wiki/Bill_Gates">reichen sollte</a>. Damit
brauchen wir jedem Prozess später nur eine Seitentabelle zuordnen.
 Zusammen mit der Entscheidung vom <a href="/aihpos/2017/06/07/aihpos-heap/">letzen Beitrag</a>, die Stacks ans Ende des verfügbaren RAM
zu legen, ergibt sich aus Kernel-Sicht folgendes Speicherlayout:</li>
</ul>

<p><img src="https://werner-matthias.github.io/SysOp/images/memory-layout.png" alt="" class="img-responsive" /></p>

<p>Alle Prozesse sollen logisch den gleichen Adressbereich haben. Wir legen
fest, dass der maximal 1 MiB große Adressbereich von 0x02000000 bis
0x020FFFFF geht. Damit ist hinreichen Platz für den Kernel und seine
Verwaltungsdaten im unteren Bereich des Speichers. Für einen Prozess
sähe der Adressbereich dann ungefähr so aus, wobei die schwarz-gelb
schraffierten Gebiete „verboten“ sind, wo ein Speicherzugriff des
Prozesses also zu einer Ausnahme führt. Ob der Prozess auf den
Adressbereich mit den Geräten zugreifen darf, hängt von seinen Rechten
ab; bei Treiberprozessen sollte man einen entsprechenden Zugriff
natürlich gestatten.</p>

<p><img src="https://werner-matthias.github.io/SysOp/images/pmemory-layout.png" alt="" class="img-responsive" /></p>

<p>Natürlich liegen die Prozesse nicht wirklich im gleichen (physischen)
Speicherbereichen. Vielmehr sind ihre Speicherseiten auf verschiedene
Platzhalter (<em>Frames</em>) im Speicher verteilt. Dies Frames, die ein
Prozess benutzt, müssen (mit Ausnahme von Speichersharing) in der Tat
verschieen sein. Daher besteht eine weitere Aufgabe neben der
Verwaltung der Abbildung (<em>mapping</em>) in der Buchhaltung über die
Framevergabe. Auch hier steht eine Designentscheidung über die Art und
Weise der Frameverwaltung an.</p>

<p>Solange wir noch kein Demand Paging haben, ist eine Buchführung
theoretisch redundant: Man kann die belegten Frames ermitteln, indem
man das Seitenverzeichnis und alle existierenden Seitentabellen
betrachtet und alle Frames in nichtaufgeführten Adressbereichen als
leer betrachtet. Aber das ist erstens ein enormer Aufwand, und
zweitens nicht sehr zukunftsträchtig, da <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/assets/img/sophia.png"> vielleicht tatsächlich
mal einen virtuellen Speicher erhalten soll.</p>

<p>Es stellt sich also die Frage, wie die Frameverwaltung organisiert
werden soll. Möglich wären – wie beim Heap – Listen mit leeren
Frame-Bereichen. Ich habe mich aber für eine andere Lösung
entschieden, die etwas unkomplizierter ist: In einem großen Bit-Array
werden alle belegten Frames markiert. Bei einem (beim Pi 1B) maximalen
RAM vom 512 MiB und einer Seitengröße von 4 kiB gibt es maximal</p>

<p>\[ \frac{512\cdot 2^{20}}{4096} = 131072\]
Frames. Wenn für jedes Frame ein Bit die Belegung anzeigt, hat das
Bit-Array eine Größe von
\[\frac{131072}{8} = 16384\;\mathsf{Byte,}\] also 16 kiB. Das ist zwar (vermutlich)
größer eine Freiframetabelle oder ein ähnliches Konstrukt im Mittel
benötigen würde, aber der <em>Worst Case</em> ist bei der Freispeichertabelle
wesentlich schlechter.<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup></p>

<h3 id="datenstrukturen">Datenstrukturen</h3>
<p>Nachdem wir die Designentscheidungen getroffen haben, können die
Datenstrukturen festgelegt werden.</p>

<h4 id="tabelleneinträge">Tabelleneinträge</h4>
<p>Die einfachsten Datenstrukturen sind die Einträge in den
Seitentabellen bzw. dem Seitenvereichnis: Das in eigentlich nur
32-Bit-Worte, in Rust also <code class="highlighter-rouge">u32</code> (oder <code class="highlighter-rouge">usize</code>):</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">PageDirectoryEntry</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">PageTableEntry</span>     <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
</code></pre></div></div>
<p>In Rust wird damit nur ein Typenalias geschaffen, für den Typencheck
sind es also immer noch ein <code class="highlighter-rouge">u32</code>. Funktionen zum Manipulieren könnten
also nicht unterscheiden, ob sie ein Eintrag in eine Seitentabelle
oder in das Seitenverzeichnis bearbeiten, man hat also keine
Typensicherheit.
Andererseits können die skalaren Grundtypen von Rust nicht einfach so
erweitert werden, wir können also keine zusätzlichen <em>Methoden</em> für
<code class="highlighter-rouge">u32</code> schreiben.</p>

<p>Um trotzdem etwas Abstraktion und Typensicherheit zu erhalten, habe
ich für die Generierung der Tabelleneinträge das
<a href="https://doc.rust-lang.org/book/first-edition/method-syntax.html#builder-pattern"><em>Builder</em>-Muster</a>
ausgewählt, also eine <code class="highlighter-rouge">struc</code>, deren Methoden
verkettet werden können und die die gewünschte Datenstruktur erzeugt.</p>

<p>Die Einträge in das Seitenverzeichnis und in eine Seitentabelle haben
ähnliche Funktionen. In einer objektorientierten Sprache würde man
dies über ein Klassenkonzept oder ein Interface abbilden. In Rust
nimmt man zur Beschreibung gemeinsamen Verhaltens einen <em>Trait</em>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// `MemoryBuilder` ist eine Builder-Struct für zur Erstellung von Einträgen</span>
<span class="c">///  in das Seitenverzeichnis oder in Seitentabellen</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">u32</span><span class="p">,</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">DirectoryEntry</span><span class="o">&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">DirectoryEntry</span><span class="o">&gt;</span><span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span>      <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span><span class="p">{}</span>

<span class="c">/// Einträge in das Seitenverzeichnis (_page directory_) und die Seitentabellen</span>
<span class="c">/// (_page table_) haben ähnliche Funktionalität. Daher haben sie einen Trait als</span>
<span class="c">/// gemeinsames Interface.</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">EntryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    
    <span class="c">/// Erzeugt einen neuen Eintrag </span>
    <span class="k">fn</span> <span class="nf">new_entry</span><span class="p">(</span><span class="n">kind</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Gibt die Art des Eintrags</span>
    <span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
    
    <span class="c">/// Setzt die Basisadresse</span>
    <span class="k">fn</span> <span class="nf">base_addr</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        
    <span class="c">/// Legt die Art des Speichers (Caching) fest</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `StronglyOrdered`  (_stikt geordnet_), siehe ARM DDI 6-15</span>
    <span class="k">fn</span> <span class="nf">mem_type</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">MemType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="c">/// Setzt die Zugriffsrechte</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: Kein Zugriff</span>
    <span class="k">fn</span> <span class="nf">rights</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">MemoryAccessRight</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, zu welcher Domain der Speicherbereich gehört</span>
    <span class="c">///</span>
    <span class="c">///   * Für Supersections und Seiten wird die Domain ignoriert</span>
    <span class="c">///   * Vorgabe: 0</span>
    <span class="k">fn</span> <span class="nf">domain</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt Speicherbereich als gemeinsam (_shared_) fest</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (nicht gemeinsam)</span>
    <span class="k">fn</span> <span class="nf">shared</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, ob ein Speicherbereich global (`false`) oder prozessspezifisch</span>
    <span class="c">/// ist. Bei prozessspezifischen Speicherbereichen wird die ASID aus dem</span>
    <span class="c">/// ContextID-Register (CP15c13) genutzt.</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (global)</span>
    <span class="c">///  * Anmerkung: aihPOS nutzt *keine* prozessspezifischen Speicherbereich</span>
    <span class="k">fn</span> <span class="nf">process_specific</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ps</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Legt fest, ob Speicherinhalt als Code ausgeführt werden darf</span>
    <span class="c">///</span>
    <span class="c">///  * Vorgabe: `false` (ausführbar)</span>
    <span class="k">fn</span> <span class="nf">no_execute</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ne</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c">/// Gibt den Eintrag zurück</span>
    <span class="k">fn</span> <span class="nf">entry</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Für die Implementierung des Traits müssen jetzt nur die Bits nach
Handbuch gesetzt werden. Ich habe für die Bitmanipulation wieder
die <code class="highlighter-rouge">Bitfield</code>-Crate genutzt. Folgender Codeausschnitt zeigt
exemplarische die Implementation der Methode, die für einen
Seitentabelleneitrag festlegt, ob die entsprechende Speicherseite
ausführbaren Code enthalten darf:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">fn</span> <span class="nf">no_execute</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ne</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">MemoryBuilder</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">TableEntry</span><span class="p">::</span><span class="n">LargePage</span> 
                <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="n">ne</span><span class="p">);</span> <span class="p">},</span>
            <span class="nn">TableEntry</span><span class="p">::</span><span class="n">SmallPage</span>
                <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ne</span><span class="p">);</span> <span class="p">},</span>
            <span class="n">_</span>   <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
        <span class="k">self</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Wenn dann ein Mapping – also eine Abbildung zwischen logischen und
physischen Adressen – festgelegt wird, werden einfach die Methoden
der Builder-struct verkettet, bis der gewünschte Eintrag
entstanden ist, wie folgendes Beispiel aus dem Initalisierungscode
zeigt:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">kpage_table</span><span class="p">[</span><span class="n">frm</span><span class="nf">.rel</span><span class="p">()]</span> <span class="o">=</span> <span class="nn">MemoryBuilder</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TableEntry</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new_entry</span><span class="p">(</span><span class="nn">TableEntry</span><span class="p">::</span><span class="n">SmallPage</span><span class="p">)</span>
            <span class="nf">.base_addr</span><span class="p">(</span><span class="n">frm</span><span class="nf">.start</span><span class="p">())</span>
            <span class="nf">.rights</span><span class="p">(</span><span class="nn">MemoryAccessRight</span><span class="p">::</span><span class="n">SysRwUsrNone</span><span class="p">)</span>
            <span class="nf">.mem_type</span><span class="p">(</span><span class="nn">MemType</span><span class="p">::</span><span class="n">NormalWT</span><span class="p">)</span>
            <span class="nf">.domain</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="nf">.entry</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="tabellen-1">Tabellen</h4>
<p>Die Tabellen (Seitentabellen und Seitenverzeichnis) sind im
Endergebnis einfache Arrays. Um aber auch hier Typensicherheit zu
erhalten und das richtige Alignment zu erzwingen, werden diese Arrays
jeweils Elemente eines Verbundstyps (<code class="highlighter-rouge">struct</code>).
Damit man trotzdem wie auf ein Array zugreifen kann, also der
<code class="highlighter-rouge">[ ]</code>-Operator funktioniert, muss der <code class="highlighter-rouge">Index</code>- und der
<code class="highlighter-rouge">IndexMut</code>-Trait implementiert werden:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">ops</span><span class="p">::{</span><span class="nb">Index</span><span class="p">,</span> <span class="n">IndexMut</span><span class="p">};</span>

<span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="nn">builder</span><span class="p">::{</span><span class="n">PageTableEntry</span><span class="p">,</span><span class="n">TableEntry</span><span class="p">,</span><span class="n">MemoryBuilder</span><span class="p">,</span><span class="n">EntryBuilder</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">super</span><span class="p">::</span><span class="n">Address</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="nd">#[repr(align(</span><span class="mi">1024</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">PageTableEntry</span><span class="p">;</span><span class="mi">256</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="c">/// Erzeugt eine neue Tabelle</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span>  <span class="n">PageTable</span> <span class="p">{</span>
        <span class="n">PageTable</span> <span class="p">{</span>
            <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">256</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">/// Füllt die Tabelle mit Seitenfehlern</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">invalidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">ndx</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">256</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span> <span class="o">=</span> <span class="nn">MemoryBuilder</span><span class="p">::</span><span class="nf">new_entry</span><span class="p">(</span><span class="nn">TableEntry</span><span class="p">::</span><span class="n">Fault</span><span class="p">)</span><span class="nf">.entry</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">/// Addresse der Tabelle</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">addr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Address</span> <span class="p">{</span>
        <span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">PageTableEntry</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">PageTableEntry</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">IndexMut</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="frames">Frames</h4>
<p>Ein Frame ist ein Bereich von Adressen, der genau eine Speicherseite
groß ist. Wir könnten also <code class="highlighter-rouge">Range&lt;usize&gt;</code> als Typ nutzen. Allerdings
werden wir auch mit anderen Adressbereichen umgehen, und so hätten wir
wieder keine Typensicherheit. Da aber Frames Gegensatz zu
Tabelleneinträgen evtl. nicht nur konstruiert und zugewiesen werden
(wir werden später einen Frame-Iterator brauchen), nehmen wir diesmal
ein anderes Muster, um <code class="highlighter-rouge">Range</code> zu erweitern: Wir schaffen einen neuen
Typ:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">Address</span>      <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">AddressRange</span> <span class="o">=</span> <span class="n">Range</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Frame</span><span class="p">(</span><span class="n">AddressRange</span><span class="p">);</span>
</code></pre></div></div>
<p>Dafür implementieren wir eine Handvoll von Methoden:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="c">/// Frame aus absoluter Framenummer</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_nr</span><span class="p">(</span><span class="n">nr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nf">Frame</span> <span class="p">(</span>
            <span class="n">AddressRange</span> <span class="p">{</span>
                <span class="n">start</span><span class="p">:</span> <span class="n">nr</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
                <span class="n">end</span><span class="p">:</span> <span class="p">(</span><span class="n">nr</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="err">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">})</span>
    <span class="p">}</span>

    <span class="c">/// Frame mit einer gegebenen Startadresse</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_start</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> - <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">Frame</span> <span class="p">(</span><span class="n">AddressRange</span> <span class="p">{</span>
            <span class="n">start</span><span class="p">:</span> <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="err">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="c">/// Frame, der gegebene Adresse enthält</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="err">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nn">Frame</span><span class="p">::</span><span class="nf">from_start</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="p">}</span>

	<span class="c">/// Start des Frames</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Address</span> <span class="p">{</span>
        <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="py">.start</span>
    <span class="p">}</span>

    <span class="c">/// Ende (inklusiv) des Frames</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Address</span> <span class="p">{</span>
        <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="py">.end</span>
    <span class="p">}</span>
    
    <span class="c">/// Absolute Nummer des Frames</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="py">.start</span> <span class="err">/</span> <span class="n">PAGE_SIZE</span>
    <span class="p">}</span>

    <span class="c">/// Nummer der Section, zu dem der Frame gehört</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">section</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="py">.start</span> <span class="err">/</span> <span class="n">SECTION_SIZE</span>
    <span class="p">}</span>

    <span class="c">/// Nummer des Frames innerhalb der Section / Seitentabelle</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">rel</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="err">.</span><span class="mi">0</span><span class="py">.start</span> <span class="o">%</span> <span class="n">SECTION_SIZE</span><span class="p">)</span> <span class="err">/</span> <span class="n">PAGE_SIZE</span>
    <span class="p">}</span>

    <span class="c">/// Iterator über Frames eines Adressbereiches</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">AddressRange</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">FrameIterator</span> <span class="p">{</span>
        <span class="n">FrameIterator</span> <span class="p">{</span>
            <span class="n">range</span><span class="p">:</span> <span class="n">AddressRange</span><span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="n">r</span><span class="py">.start</span><span class="p">,</span>
                                 <span class="n">end</span><span class="p">:</span>   <span class="n">r</span><span class="py">.end</span> <span class="err">-</span> <span class="mi">1</span><span class="p">},</span>
            <span class="n">current</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Frame</span><span class="p">::</span><span class="nf">from_addr</span><span class="p">(</span><span class="n">r</span><span class="py">.start</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Die <code class="highlighter-rouge">iter()</code>-Methode gibt einen Iterator zurück, der natürlich auch
implementiert werden muss. Die Idee dabei ist, dass für einen
beliebigen gegebenen Adressbereich alle darin (ggf. teilweise)
enthaltenen Frames iteriert wird.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">FrameIterator</span> <span class="p">{</span>
    <span class="n">range</span><span class="p">:</span>   <span class="n">AddressRange</span><span class="p">,</span>
    <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">FrameIterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.current</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nn">Frame</span><span class="p">::</span><span class="nf">from_start</span><span class="p">(</span><span class="k">self</span><span class="py">.current</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.start</span><span class="p">());</span>
            <span class="k">self</span><span class="py">.current</span> <span class="o">=</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="nf">.end</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.range.end</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="nn">Frame</span><span class="p">::</span><span class="nf">from_start</span><span class="p">(</span><span class="n">tmp</span><span class="nf">.start</span><span class="p">()</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
                <span class="p">};</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="frame-manager">Frame-Manager</h4>
<p>Der Frame-Manager verwaltet – wie oben diskutiert – ein Bitarray. Er
enthält zusätzlich eine Indexvariable, die auf den ersten freien Frame
zeigt. Da Reservierung nicht zusammenhängend sein müssen und
es eine feste Stückelung gibt, ist Verschnitt kein Problem.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">BITVECTOR_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="p">(</span><span class="n">MEM_SIZE</span> <span class="err">/</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>

<span class="c">/// FrameManager verwaltet die Allozierung von Frames.</span>
<span class="c">/// Jedes Bit in `bits` steht für einen Frame.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FrameManager</span> <span class="p">{</span>
    <span class="n">bits</span><span class="p">:</span> <span class="p">[</span><span class="nb">u64</span><span class="p">;</span> <span class="n">BITVECTOR_SIZE</span><span class="p">],</span>
    <span class="n">first_free</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Die Suche nach einem freien Frame ist linear und hat somit eine
Komplexität von \(\mathcal{O}(n)\).</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">/// Sucht den nächsten freien Frame und gibt die Nummer zurück</span>
    <span class="k">fn</span> <span class="nf">find_next_free</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ndx</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">self</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">ndx</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ndx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.bit_length</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">ndx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ndx</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Ansonsten ist der Frame-Manager ziemlich unkomplizert
implementiert. Einzig bemerkenswert ist vielleicht, dass wir bei ihm das
<a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton-Muster</a>
implementieren (schließlich wollen wir nicht Gefahr laufen, mehrere
Instanzen einer so großen Datenstruktur im Speicher und wohlmöglich
auf dem Stack zu haben.)<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> Daher ist der Konstruktor und die
statische Variable, die wieder <code class="highlighter-rouge">NoConcurrency</code> nutzt, privat:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">/// Erzeugt einen neuen Framemanager</span>
    <span class="c">///</span>
    <span class="c">/// # Anmerkung</span>
    <span class="c">/// Der Framemanager ist ein Singleton, daher ist `new()` nicht öffentlich</span>
    <span class="c">/// Zugriff erhält man über die assoziierte Methode `get()`.</span>
    <span class="k">const</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">FrameManager</span> <span class="p">{</span>
        <span class="n">FrameManager</span> <span class="p">{</span>
            <span class="n">bits</span><span class="p">:</span> <span class="p">[</span><span class="mi">0u64</span><span class="p">;</span> <span class="n">BITVECTOR_SIZE</span><span class="p">],</span>
            <span class="n">first_free</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
		
<span class="c">// ...</span>

<span class="c">/// Das Singleton für den Framemanager, nicht geschützt vor nebenläufigen Zugriff</span>
<span class="k">static</span> <span class="n">FRAME_MANAGER</span><span class="p">:</span> <span class="n">NoConcurrency</span><span class="o">&lt;</span><span class="n">FrameManager</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">NoConcurrency</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">FrameManager</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
</code></pre></div></div>
<p>Zugriff erhält man über eine assoziierte Methode der <code class="highlighter-rouge">struct
FrameManager</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">/// Gibt eine Referenz auf Framemanager-Singleton zurück</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="k">mut</span> <span class="n">FrameManager</span> <span class="p">{</span>
        <span class="n">FRAME_MANAGER</span><span class="nf">.get</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Und da wir gerade dabei sind, machen wir auch das Seitenverzeichnis
auf die gleiche Weise zum Singleton.</p>

<h3 id="in-die-niederungen">In die Niederungen</h3>
<p>Bisher konnten wir mit den Abstaktionen, die uns Rust zur Verfügung
gestellt hat, gut auskommen. Das ist nun vorbei: Die eigentliche
Aktivierung des Pagings verlangt Assembler-Code. Glücklicherweise kann
dieser ja gut in Rust eingebettet werden mit Hilfe des
(selbstverständlich unsicheren) Macros <code class="highlighter-rouge">asm!()</code>.</p>

<p>Die Aktivierung erfolgt durch setzen eines bstimmten Bits in einem
bestimmten Register des CP15-Koprozessors. Dieser Koprozessor ist nur
konzeptionell ein eigener Prozessor und auf einem Chip zusammen mit
dem „Rest-ARM“.
Das Technischen Manual des ARM1176JZF-S schreibt folgende Schritte bei
der MMU-Aktivierung vor, (vgl. Abschnitt 6.4.1, S. 6-9):</p>

<ol>
  <li>Programmiere alle relevanten CP15-Registers.</li>
  <li>Programmere Seitenverzeichnis und Seitentabellen wie benötigt.</li>
  <li>Schalte den Instruktionscache ab und mache seine Einträge
     ungültig. Er kann nach dem Start der MMU wieder aktiviert
     werden.</li>
  <li>Setze das Bit 0 im CP15-Steuerregister</li>
</ol>

<p>Das setzen wir so um (und legen gleichzeitig noch fest, dass wir das
ARMv6-MMU-Protokoll ohne Subpages nutzen wollen:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">start</span><span class="p">(){</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">reg</span><span class="p">:</span> <span class="nb">u32</span><span class="p">;</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">clean</span><span class="p">();</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">disable_instruction</span><span class="p">();</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">invalidate_instruction</span><span class="p">();</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">disable_data</span><span class="p">();</span>
        <span class="nn">Tlb</span><span class="p">::</span><span class="nf">flush</span><span class="p">();</span>
        <span class="nd">asm!</span><span class="p">(</span><span class="s">"mrc p15, 0, $0, c1, c0, 0"</span><span class="p">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
        <span class="n">reg</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="k">true</span><span class="p">);</span>  <span class="c">// Subpages aus, ARMv6-Erweiterungen an</span>
        <span class="n">reg</span><span class="nf">.set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="k">true</span><span class="p">);</span>   <span class="c">// MMU an</span>
        <span class="nn">Cpu</span><span class="p">::</span><span class="nf">data_synchronization_barrier</span><span class="p">();</span>
        <span class="nd">asm!</span><span class="p">(</span><span class="s">"mcr p15, 0, $0, c1, c0, 0"</span><span class="p">::</span><span class="s">"r"</span><span class="p">(</span><span class="n">reg</span><span class="p">)::</span><span class="s">"volatile"</span><span class="p">);</span>
        <span class="nn">Cpu</span><span class="p">::</span><span class="nf">prefetch_flush</span><span class="p">();</span>
        <span class="nn">Cpu</span><span class="p">::</span><span class="nf">data_synchronization_barrier</span><span class="p">();</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">enable_instruction</span><span class="p">();</span>
        <span class="nn">Cache</span><span class="p">::</span><span class="nf">enable_data</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Die anderen <code class="highlighter-rouge">Cpu</code>- und <code class="highlighter-rouge">Cache</code>-Methoden sind ebenfalls Methoden, wo
die eigentliche Arbeit durch Assemblercode verrichtet wird. Da es hier
auf jedes einzelne Bit ankommt, gilt die Devise: „Genau das Handbuch
lesen und exakt nachvollziehen“. Wie dies im einzelnen aussieht, kann
wieder auf
<a href="https://github.com/werner-matthias/aihPOS/tree/master/kernel/src/hal/cpu">GitHub</a>
betrachtet werden.</p>
<h2 id="schlussbemerkung">Schlussbemerkung</h2>
<p>Die Implementation einer MMU-Steuerung ist eine heikle Sache. Ich war
froh, als der Code zum ersten Mal ohne einen „Abort“ aus der
MMU-Aktivierungsmethode zurückgekehrt ist.</p>

<p>Natürlich kann ein solcher Abort auch abgefangen und eine schöne
Meldung ausgegenen werden. Und natürlich habe ich das auch gemacht,
aber davon berichte ich in einer der nächsten Folgen dieses Blogs.</p>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/aihpos/2017/06/07/aihpos-heap/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="https://werner-matthias.github.io/SysOp/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Umgangssprachlich wird mit <em>Paging</em> fast immer <em>Demand Paging</em>,
    also die virtuelle Speicherverwaltung mit Auslagerung auf die
    Festplatte gemeint. Jedoch lässt sich eine seitenbasierte gestreute
    Adressierung auch sinnvoll ohne Auslagerung einsetzen. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Das hier beschriebene Paging-Schema entspricht ARMv6. Der
    Prozessor ist in einigen Aspekten der Speicherverwaltung
    rückwärtskompatibel zu ARMv5 (z.B. Supbages). Dies werden wir nicht
    benutzen. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Es gibt auch ein Schema mit zwei Seitenverzeichnissen, das hier
    aber nicht betrachtet wird. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Im pathologischen Fall würde jeder zweite Frame frei sein. Eine
    Speicherstruktur, die die Adressen (4 Byte) und die Länge
    (4 Byte) der Leer-Frame-Bereiche speichert, bräuchte dann
    mindestens \(\frac{131072}{2}\cdot(4 + 4) = 524288\) Byte,
    also ein halbes MiB! <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Genau genommen haben wir das Muster bereits beim Framebuffer
    benutzt. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

	                </span>
			
						<div id="page-meta" class="t30">
				<p>
					<!-- Look the author details up from the site config. -->
					
					<!-- Output author details if some exist. -->
					
					<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name" class="pr20 icon-edit"><a href="http://osg.informatik.tu-chemnitz.de/Staff/M_Werner/index.php?lang=en" target="_blank"> Matthias Werner</a></span>
				</span>
				

				
				<time class="icon-calendar pr20" datetime="2017-06-18" itemprop="datePublished"> 2017-06-18</time>
				

				<span class="icon-archive pr20"> AIHPOS · COMPUTER</span>
				<br />
				<span class="pr20"><span class="icon-price-tag pr10"> Rust</span> <span class="icon-price-tag pr10"> aihpos</span> <span class="icon-price-tag pr10"> paging</span> </span>
			</p>

			<div id="post-nav" class="row">
				
				<div class="small-5 columns"><a class="button small radius prev" href="https://werner-matthias.github.io/SysOp/aihpos/2017/06/07/aihpos-heap/">&laquo; Wir machen einen Haufen</a></div><!-- /.small-4.columns -->
				
				<div class="small-2 columns text-center"><a class="radius button small" href="https://werner-matthias.github.io/SysOp/blog/archive/" title="Blog Archiv">Archiv</a></div><!-- /.small-4.columns -->
				
				<div class="small-5 columns text-right"><a class="button small radius next" href="https://werner-matthias.github.io/SysOp/meta/2017/06/19/hello-jekyll/">Hello Jekyll &raquo;</a></div><!-- /.small-4.columns -->
				
			</div>
			</div><!--  /.page-meta -->
			

	                
		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">Über diese Website</h5>

            <p class="shadow-black">
              Matthias Werners Blog. 
              <a href="https://werner-matthias.github.io/SysOp/info/">Mehr ›</a>
            </p>
          </div><!-- /.large-6.columns -->


          <div class="small-6 medium-3 large-3 large-offset-1 columns">
            
              
              <ul class="no-bullet shadow-black">
              
              </ul>
          </div><!-- /.large-4.columns -->


          <div class="small-6 medium-3 large-3 columns">
            
              
            <ul class="no-bullet shadow-black">
            
            </ul>
          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="https://werner-matthias.github.io/SysOp/assets/js/javascript.min.js"></script>














</body>
</html>

