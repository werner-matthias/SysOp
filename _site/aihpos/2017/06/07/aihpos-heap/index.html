<!doctype html>
<html class="no-js" lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Wir machen einen Haufen</title>
	<link rel="stylesheet" type="text/css" href="https://werner-matthias.github.io/SysOp/assets/css/styles_feeling_responsive.css" />
	<script src="https://werner-matthias.github.io/SysOp/assets/js/modernizr.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
      }
    });
  </script>

  <noscript>
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css' />
  </noscript>

  
	
	<meta name="description" content="Die unterste Schicht im Mikrokernel ist die Kernel-Speicherverwaltung. In diesem Beitrag werden die Stacks und der Heap des Kernels implementiert."/>

	

	



	
	<link rel="icon" sizes="32x32" href="https://werner-matthias.github.io/SysOp/assets/img/favicon-32x32.png" />




	
	<link rel="icon" sizes="192x192" href="https://werner-matthias.github.io/SysOp/assets/img/touch-icon-192x192.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-180x180-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-152x152-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-144x144-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-120x120-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-114x114-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-76x76-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-72x72-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-precomposed.png" />	




	
	<meta name="msapplication-TileImage" content="https://werner-matthias.github.io/SysOp/assets/img/msapplication_tileimage.png" />




	
	<meta name="msapplication-TileColor" content="#fabb00" />



	<!-- Facebook Optimization -->
	<meta property="og:locale" content="en_EN" />
	
	<meta property="og:title" content="Wir machen einen Haufen" />
	<meta property="og:description" content="Die unterste Schicht im Mikrokernel ist die Kernel-Speicherverwaltung. In diesem Beitrag werden die Stacks und der Heap des Kernels implementiert." />
	<meta property="og:url" content="https://werner-matthias.github.io/SysOp//aihpos/2017/06/07/aihpos-heap/" />
	<meta property="og:site_name" content="Systems Operational" />
	

	

	<!-- Search Engine Optimization -->
	

	<link type="text/plain" rel="author" href="https://werner-matthias.github.io/SysOp/humans.txt" />

	

	
</head>
   <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   </script>
</head>
<body id="top-of-page" class="page-fullwidth">
	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="https://werner-matthias.github.io/SysOp" class="icon-tree"> Systems Operational</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        

              

          
          
        

              

          
          
        

              

          
          
        

              

          
          
            
            
              <li class="divider"></li>
              <li><a href="https://werner-matthias.github.io/SysOp/about/">Über mich</a></li>

            
            
          
        
        
      </ul>

      <ul class="left">
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/">Start</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          

            
            

              <li class="has-dropdown">
                <a href="https://werner-matthias.github.io/SysOp/blog/">Blog</a>

                  <ul class="dropdown">
                    

                      

                      <li><a href="https://werner-matthias.github.io/SysOp/blog/archive/">Archive</a></li>
                    
                  </ul>
                  
              </li>
              <li class="divider"></li>
            
          
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/blog/aihpos/">aihPos</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead-no-image-header">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="https://werner-matthias.github.io/SysOp" title="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
				<img src="https://werner-matthias.github.io/SysOp/assets/img/logo.png" alt="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->









	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Ein Betriebsystem für die Lehre</p>
				<h1>Wir machen einen Haufen</h1>
			</header>

			

			<span itemprop="articleSection">
	                <p><strong>Inhalt</strong></p>
<ul id="markdown-toc">
  <li><a href="#speicher-in-verschiedenen-geschmacksrichtungen" id="markdown-toc-speicher-in-verschiedenen-geschmacksrichtungen">Speicher in verschiedenen Geschmacksrichtungen</a></li>
  <li><a href="#stack" id="markdown-toc-stack">Stack</a>    <ul>
      <li><a href="#prozessor-modi" id="markdown-toc-prozessor-modi">Prozessor-Modi</a></li>
      <li><a href="#ja-wo-liegen-sie-nur" id="markdown-toc-ja-wo-liegen-sie-nur">Ja, wo liegen sie nur?</a></li>
      <li><a href="#hal" id="markdown-toc-hal">HAL</a></li>
    </ul>
  </li>
  <li><a href="#heap" id="markdown-toc-heap">Heap</a>    <ul>
      <li><a href="#rust-allocator" id="markdown-toc-rust-allocator">Rust Allocator</a></li>
      <li><a href="#algorithmus" id="markdown-toc-algorithmus">Algorithmus</a></li>
    </ul>
  </li>
  <li><a href="#vektoren-hashes--co" id="markdown-toc-vektoren-hashes--co">Vektoren, Hashes &amp; Co</a></li>
</ul>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/aihpos/2017/05/14/aihpos-umrustung/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="https://werner-matthias.github.io/SysOp/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<p><img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> soll ein dynamisches Betriebssystem werden, also eines, bei denen die Anzahl der Prozesse sich zur Laufzeit ändern kann. Unser Mikrokernel hat eine klassische Architektur, die aus vier Schichten besteht:</p>

<ul>
  <li>Schicht 4: der Kernoperation, der wie Prozessverwaltung, Prozessinteraktion oder Prozessspeichermanagement</li>
  <li>Schicht 3: Prozesswechseloperationen; hier wird die Abstraktion Prozess gewährleistet</li>
  <li>Schicht 2: Datenstrukturen</li>
  <li>Schicht 1: Kernel-Speicherverwaltung</li>
</ul>

<p><img src="https://werner-matthias.github.io/SysOp/images/mk-architektur.png" alt="" class="img-responsive" /></p>

<p>Damit wäre eine der ersten Aufgaben, sich um den Speicher kümmern.</p>

<h2 id="speicher-in-verschiedenen-geschmacksrichtungen">Speicher in verschiedenen Geschmacksrichtungen</h2>

<p>Die Speicherverwaltung in Betriebssystemen hat verschiedene Aspekte:</p>
<ul>
  <li>Prozesse und der Kernel brauchen eine Buchführung über bei Operationen wie <code class="highlighter-rouge">malloc</code> oder <code class="highlighter-rouge">new</code> allozierten<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>  Speicher. Das Modell des Speichers ist hier ein linearer
 Adressraum. Die Herausforderung besteht, möglichst wenig Overhead  und eine möglichst kleinen Verschnitt zu produzieren.</li>
  <li>Der insgesamt zur Verfügung stehende Speicher muss zwischen den einzelnen Prozessen verteilt werden. Hierbei geht es nicht nur um die Reservierung von
 Speicherbereichen, sondern um die Abbildung der Prozesssicht (logische Adressen) auf die Prozessorsicht (physische Adresse). Verwaltungseinheiten sind hier in der Regel
 physische Speicherseiten (Pages) oder Segmente.</li>
  <li>Die Prozesse und der Kernel müssen vor ungewollten Speichereingriffen anderer Prozessen geschützt werden.</li>
  <li>Häufig  sollen die vorhandenen Speicherreserven durch Nutzung einer Speicherhierachie virtuell vergrößert werden.</li>
</ul>

<p><img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> soll (zunächst) die ersten drei Aspekte unterstützen; eine virtuelle<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>  Speicherverwaltung kann erst in Angriff genommen werden, wenn es Treiber für
Speichermedien wie die SD-Karte oder externe USB-Laufwerke gibt.</p>

<p>Dabei muss erst einmal der Kernel selbst seinen Speicher verwalten. Dabei stellt sich natürlich die Frage: wie hat er das in unseren bisherigen Programmen gemacht? Da
haben wir doch auch schon Speicher (in Form von Variablen) benutzt. Das waren einmal statische (aus Programmsicht: globale) Variablen, wie der Framebuffer. Diese haben
eine Lebenzeit, die die Lebenzeit des ganzen Programmes umfasst. Variablen mit beschränkter Lebenzeit muss zur Laufzeit Speicher alloziert werden.
Dies wird auf zwei verschiedene Arten und an zwei verschiedenen Orten realisert<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> :</p>
<ul>
  <li>Auf dem Stack. Dort werden nicht nur Rücksprungadressen gespeichert, sondern auch <em>lokale</em> Variablen einer Funktion. Beim Verlassen der Funktion werden diese
 automatisch aufgeräumt.</li>
  <li>Auf dem Heap. Dort werden Variablen angelegt, die die Laufzeit einer Funktion überdauern. Diese müssen dann entweder manuell weggeräumt werden, oder es existiert eine
 Speicherberäumung (<em>garbage collection</em>)</li>
</ul>

<h2 id="stack">Stack</h2>
<h3 id="prozessor-modi">Prozessor-Modi</h3>
<p>Bisher haben wir ausschließlich den Stack benutzt, und zwar den Stack im SVC-Mode. Im Gegensatz zu beispielsweise dem x86-Prozessoren kennt ARM nämlich mehrere Stacks.
Diese sind an Prozessor-Modi gebunden. Im einzelnen es beim ARM1176JZF-S folgende Modi:</p>
<ul>
  <li>Supervisor-Mode (SVC): Mode, in dem die CPU startet und mit dem wir es bisher zu tun hatten. Er ist privilegiert, hat also die volle Kontrolle über die CPU.</li>
  <li>User-Mode: unprivilegierter Mode, der für normale Programme genutzt wird. </li>
  <li>System-Mode: privilegierter Mode mit der gleichen „Sicht“ wie der User-Mode.</li>
  <li>Interrupt-Mode (IRQ): Mode in dem zur Behandlung eines  Interrupts gewechselt wird.</li>
  <li>Fast-Interrupt-Mode (FIQ): Mode für die besonders schnelle Behandlung eines  Interrupts.</li>
  <li>Memory-Abort (ABT): Mode, in dem zur Behandlung eines Traps (also internen Interrupts) gewechselt wird, der durch einen ungültigen Speicherzugriff ausgelöst wird. Ursache können z.B. fehlende Zugriffsrechte sein.</li>
  <li>Undefined-Instruction-Exception (UND): Ein weiterer Trap-Behandlungsmode, in den gewechselt wird, wenn ein unbekannter Op-Code gelesen wird. Damit kann ein erweiterter Befehlssatz emuliert werden.</li>
  <li>Secure-Monitor-Mode (MON): Der ARM1176JZF-S hat eine Erweiterung (TrustZone), bei der zwischen einer vertrauenswürdigen und einer unsicheren „Welt“ unterschieden wird. Der Secure-Monitor-Mode dient der Interaktion dieser Welten.</li>
</ul>

<p>Da wir die TrustZone-Erweiterung nicht nutzen wollen, ist der letzte Mode für uns nicht interessant. Um die andern müssen wir uns kümmern. Dabei hat jeder Mode seinen
eigenen Stackpointer und sein eigenes Link-Register. Eine Ausnahme ist der System-Mode, der sich alle Register mit dem User-Mode teilt. Wir werden aber nicht für jeden
Mode einen eigenen Stack anlegen: Da die meisten Modi entweder ihren Stack aufräumen, oder nicht zurückkehren, können sie sich (erst mal) einen Stack teilen. Dieser Stack
soll im weiteren Interrupt-Stack heißen.</p>

<h3 id="ja-wo-liegen-sie-nur">Ja, wo liegen sie nur?</h3>
<p>Wo sollen nun die Stacks liegen? Da Stacks traditionell<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup> nach „untern“ wachsen, legen wir sie möglichst „hoch“.
Da der Interrupt-Stack vorhersagbarer als der SVC-Stack ist, setzen wir ihn ganz an das Ende des verfügbaren Speichers und den SVC-Stack ein Stück weit darunter.
Allerdings kann das Ende des Speichers variieren, da es zur Bootzeit die Aufteilung zwischen ARM und GPU geändert werden kann.
Glücklicherweise haben wir in der <a href="/2017/04/26/aihpos-4-postman">vorletzten Folge</a> das
Mailbox-System implementiert, mit dem wir ja das Ende des Speichers herausfinden können.</p>

<p>Allerdings geschieht dies zur Laufzeit – d.h., wir brauchen bereits einen Stack. Wir müssen also mit einem provisorischen Stack beginnen um später zu wechseln.
Damit sieht unsere Einsprungssequenz in den Kernel jetzt so aus:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="n">no_mangle</span><span class="p">]</span>      <span class="c">// Name wird für den Export nicht verändert</span>
<span class="cp">#[naked]</span>          <span class="c">// Kein Prolog, da dieser den Stack nutzen würde, den wir noch nicht gesetzt haben</span>
<span class="cp">#[allow(unreachable_code)]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">kernel_start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Zum Start existiert noch kein Stack. Daher setzen wir einen temporären Stack, der nach dem Textsegment liegt.</span>
    <span class="c">// Das Symbol ist in "layout.ld" definiert.</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">__kernel_stack</span><span class="p">}</span>  <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
    <span class="c">// Nun kann die Größe des Speichers und damit die Adresse für den "echten" Stacks bestimmt werden</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="nf">determine_svc_stack</span><span class="p">());</span>
    <span class="nf">kernel_init</span><span class="p">();</span>
    <span class="nd">unreachable!</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#[inline(never)]</span> <span class="c">// Verbietet dem Optimizer, kernel_init() und darin aufgerufene Funktionen mit kernel_start()</span>
                 <span class="c">// zu verschmelzen. Dies würde wegen #[naked]/keinen Stack schief gehen</span>
<span class="cp">#[allow(unreachable_code)]</span>
<span class="k">fn</span> <span class="nf">kernel_init</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
    <span class="nf">report</span><span class="p">();</span>
    <span class="nf">init_mem</span><span class="p">();</span>
    <span class="nf">test</span><span class="p">();</span>
    <span class="k">loop</span> <span class="p">{}</span>
    <span class="nd">unreachable!</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">determine_irq_stack</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="nf">report_memory</span><span class="p">(</span><span class="nn">MemReport</span><span class="p">::</span><span class="n">ArmSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0xFFFFFFFC</span><span class="p">;</span>
    <span class="n">addr</span>
<span class="p">}</span>

<span class="cp">#[inline(never)]</span>
<span class="k">fn</span> <span class="nf">determine_svc_stack</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="nf">report_memory</span><span class="p">(</span><span class="nn">MemReport</span><span class="p">::</span><span class="n">ArmSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0xFFFFFFFC</span><span class="p">)</span> <span class="o">-</span> <span class="n">IRQ_STACK_SIZE</span><span class="p">;</span>
    <span class="n">addr</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">init_mem</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">init_stacks</span><span class="p">();</span>
    <span class="nf">init_heap</span><span class="p">();</span>
    <span class="nf">init_paging</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">init_stacks</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Stack für die anderen Ausnahme-Modi.  Irq, Fiq, Abort und Undef teilen sich einen Stack, der System-Mode nutzt</span>
    <span class="c">// den User-Mode-Stack und muss nicht gesetzt werden.</span>
    <span class="k">let</span> <span class="n">adr</span> <span class="o">=</span> <span class="nf">determine_irq_stack</span><span class="p">();</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_mode</span><span class="p">(</span><span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Irq</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_mode</span><span class="p">(</span><span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Fiq</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_mode</span><span class="p">(</span><span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Abort</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_mode</span><span class="p">(</span><span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Undef</span><span class="p">);</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_stack</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
    <span class="c">// ...und zurück in den Svc-Mode</span>
    <span class="nn">Cpu</span><span class="p">::</span><span class="nf">set_mode</span><span class="p">(</span><span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Svc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">init_heap</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">unimplemented!</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">init_paging</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">unimplemented!</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="hal">HAL</h3>
<p><code class="highlighter-rouge">Cpu::set_mode()</code> und <code class="highlighter-rouge">Cpu::set_stack()</code> sind natürlich keine Funktionen, die Rust bekannt sind. Der Übersichtlichkeit halber habe ich allen Assembler-Code in ein eigenes
Modul gepackt, das „HAL“ heißt. HAL steht klassischerweise für „<em>Hardware Abstraction Layer</em>“. Allerdings ist die Abstraktion in <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> sehr dünn, ein Port über die
ARM-Architektur hinaus bedürfte etwas mehr Aufwand. Der Code für <code class="highlighter-rouge">Cpu::set_mode()</code> und <code class="highlighter-rouge">Cpu::set_stack()</code> sieht derzeit so aus:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// Siehe ARM Architectur Reference Manual A2-3</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ProcessorMode</span> <span class="p">{</span>
    <span class="n">User</span>   <span class="o">=</span> <span class="mi">0x10</span><span class="p">,</span>
    <span class="n">Fiq</span>    <span class="o">=</span> <span class="mi">0x11</span><span class="p">,</span>
    <span class="n">Irq</span>    <span class="o">=</span> <span class="mi">0x12</span><span class="p">,</span>
    <span class="n">Svc</span>    <span class="o">=</span> <span class="mi">0x13</span><span class="p">,</span> 
    <span class="n">Abort</span>  <span class="o">=</span> <span class="mi">0x17</span><span class="p">,</span>
    <span class="n">Undef</span>  <span class="o">=</span> <span class="mi">0x1B</span><span class="p">,</span>
    <span class="n">System</span> <span class="o">=</span> <span class="mi">0x1F</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Cpu</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Cpu</span> <span class="p">{</span>
    <span class="cp">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">ProcessorMode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span><span class="p">{</span>
            <span class="k">match</span> <span class="n">mode</span> <span class="p">{</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">User</span> <span class="k">=&gt;</span>   <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x10"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Fiq</span> <span class="k">=&gt;</span>    <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x11"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Irq</span> <span class="k">=&gt;</span>    <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x12"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Svc</span> <span class="k">=&gt;</span>    <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x13"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Abort</span> <span class="k">=&gt;</span>  <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x17"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">Undef</span> <span class="k">=&gt;</span>  <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x1B"</span><span class="p">),</span>
                <span class="nn">ProcessorMode</span><span class="p">::</span><span class="n">System</span> <span class="k">=&gt;</span> <span class="nd">asm!</span><span class="p">(</span><span class="s">"cps 0x1F"</span><span class="p">),</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_stack</span><span class="p">(</span><span class="n">adr</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span><span class="p">{</span>
            <span class="nd">asm!</span><span class="p">(</span><span class="s">"mov sp, $0"</span><span class="p">::</span><span class="s">"r"</span><span class="p">(</span><span class="n">adr</span><span class="p">)::</span><span class="s">"volatile"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>    
</code></pre>
</div>
<h2 id="heap">Heap</h2>
<p>Nachdem die Stacks initialisiert sind, kümmern wir und um den Kernel-Heap. Es stellt sich die Frage, wie groß der Heap sein soll.
Das ist schlecht beantwortbar, da wir viele Aspekte von <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> noch nicht kennen. Natürlich können wir versuchen, ihn auf den <em>worst case</em> auszulegen,
aber das würde für den Großteil der Fälle eine Verschwendung bedeuten. Am besten wäre es, wenn der Heap erst mal eher klein ist und später wächst.
Allerdings ist das problematisch: der Heap ist ein zusammenhängender Adressraum. Wenn in der Zwischenzeit eine bestimmte Adresse anderweitig vergeben ist (sagen wir mal
an einen Prozess), kann der Heap nicht weiter wachsen.<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> An dieser Stelle kommt zum ersten Mal die gestreute Adressierung ins Spiel, die dafür sorgen, dass physisch
unzusammenhängende Adressbereiche einen logisch zusammenhängenden Adressraum bilden. Für die gestreute Adressierung ist die MMU zuständig – wir betrachten das später.
Erst einmal ist es nur wichtig zu vermerken, dass es einen Zusammenhang gib, den wir berücksichtigen sollten.</p>

<h3 id="rust-allocator">Rust Allocator</h3>
<p>Die Module, die den Heap verwalten, heißen in Rust „<em>Allokatoren</em>“. Rust wird mit zwei verschiedenen Allokatoren ausgeliefert, <code class="highlighter-rouge">malloc</code>(wohlbekannt aus der
C-Standardbibliothek) und <code class="highlighter-rouge">jemalloc</code>. Beide nutzen jedoch Betriebssystemrufe, die unter <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> erstens nocht gar nicht existieren, und zweitens im Kernel schlecht genutzt
werden könnten – also fallen beide aus.</p>

<p>Glücklicherweise kennt Rust das Konzept von maßgeschneiderten Allokatoren (<em>custom allocators</em>). Für einen solchen Allokator gibt es einige Spielregeln:</p>

<div class="alert-box warning radius "><h4 class="altert warning">Achtung</h4>
<p><em>Das Konzept der Allokatoren hat sich mit der neuen Allokator-API grundlegend gewandelt.<br />
Die folgenden Betrachtungen lasse ich wiederum  aus „historischen“ Gründen stehen.</em></p>
</div>

<ul>
  <li>Er muss in einer eigenen Bibliothek stehen, die mit <code class="highlighter-rouge">#![allocator]</code> dekoriert ist.</li>
  <li>Die Bibliothek muss folgende fünf Funktionen zur Verfügung stellen:
    <ul>
      <li><code class="highlighter-rouge">pub extern fn __rust_allocate(size: usize, align: usize) -&gt; *mut u8 </code></li>
      <li><code class="highlighter-rouge">pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) </code></li>
      <li><code class="highlighter-rouge">pub extern fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,  align: usize) -&gt; *mut u8</code></li>
      <li><code class="highlighter-rouge">pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize, size: usize, align: usize) -&gt; usize</code></li>
      <li><code class="highlighter-rouge">pub extern fn __rust_usable_size(size: usize, _align: usize) -&gt; usize</code></li>
    </ul>
  </li>
  <li>Die Bibliothek darf kein anderes Crate nutzen, das selbst einen Allokator benötigt.</li>
</ul>

<p>Da unser Allokator (später) mit der MMU-Steuerung zusammenarbeiten muss, ist die Forderung nach einer eigenen Bibliothek eher hinderlich. Wir behelfen uns mit einem
Trick, um Callbacks und ähnliches zu umgehen: Alle Funktionen rufen äquivalente Funktionen, die in der Bibliothek unaufgelöst bleiben und durch den Kernel direkt zu
Verfügung gestellt werden.
Dazu legen wir ein Verzeichnis <strong>libs</strong> an, und darin eine Untercrate <strong>kalloc</strong>:</p>
<div class="window">
          <nav class="control-window">
            <a href="#finder" class="close" data-rel="close">close</a>
            <a href="#" class="minimize">minimize</a>
            <a href="#" class="deactivate">deactivate</a>
          </nav>
          <h1 class="titleInside">Terminal</h1>
          <div class="container"><div class="terminal"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">$</span>
<span class="line-number">$</span>
<span class="line-number">$</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">$</span>
<span class="line-number">&nbsp;</span></pre></td><td class="code"><pre><code><span class="line command">mkdir libs</span><span class="line command">cd libs</span><span class="line command">cargo new kalloc</span><span class="line output">    Created library `kalloc` project
</span><span class="line command">ls kalloc</span><span class="line output">Cargo.toml	  src</span></code></pre></td></tr></table></div></div>
        </div>
<p>Die Datei <kbd>lib.rs</kbd> in <kbd>src</kbd> ist daher recht schlicht:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">allocator</span><span class="p">)]</span> 
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">allocator</span><span class="p">]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">no_std</span><span class="p">]</span>

<span class="c">///! Rust verlangt für einen Allocator eine eigene Bibliothek, die mit #![allocator] dekoriert ist.</span>
<span class="c">///! Um bei Erschöpfung des Heaps eine Seitenneuzuweisung ohne Systemruf und Callback auslösen zu können,</span>
<span class="c">///! ist die eigentliche Funktionalität in mem implementiert.</span>

<span class="k">extern</span> <span class="s">"Rust"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">aihpos_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">aihpos_deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">aihpos_usable_size</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">aihpos_reallocate_inplace</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                                    <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">aihpos_reallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                         <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// Die offizielle Schnittstelle zu Rust sieht für einen Allocator so aus,</span>
<span class="c">// vgl. Rust - The Unstable Book: https://doc.rust-lang.org/nightly/unstable-book/language-features/allocator.html</span>
<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">__rust_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span>
        <span class="nf">aihpos_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">__rust_deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span>
        <span class="nf">aihpos_deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">__rust_usable_size</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span>
        <span class="nf">aihpos_usable_size</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">__rust_reallocate_inplace</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span>
<span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span>
        <span class="nf">aihpos_reallocate_inplace</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">__rust_reallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                                <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span>
        <span class="nf">aihpos_reallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
<p>Dies gibt uns die Chance, das eigentliche Heap-Management direkt im Kernel zu implementieren. Dazu muss im Haupt-Cargo-File noch die entsprechende Abhängigkeit deklariert
werden:</p>
<div class="language-toml highlighter-rouge"><pre class="highlight"><code><span class="nn">[dependencies]</span>
<span class="py">bit_field</span> <span class="p">=</span> <span class="s">"0.7.0"</span>
<span class="py">compiler_builtins</span> <span class="p">=</span> <span class="err">{</span> <span class="err">git</span> <span class="err">=</span> <span class="s">"https://github.com/rust-lang-nursery/compiler-builtins"</span><span class="p">,</span> <span class="err">features</span> <span class="err">=</span> <span class="nn">["mem"]</span> <span class="err">}</span>
<span class="py">compiler_error</span> <span class="p">=</span> <span class="s">"0.1.1"</span>
<span class="py">kalloc</span> <span class="p">=</span>  <span class="err">{</span> <span class="err">version</span> <span class="err">=</span> <span class="s">"0.1.0"</span><span class="p">,</span> <span class="err">path</span> <span class="err">=</span> <span class="s">"libs/kalloc"</span> <span class="err">}</span>
</code></pre>
</div>

<h3 id="algorithmus">Algorithmus</h3>
<p>Zur Verwaltung von gibt es eine ganze Reihe von Ansätzen. Prinzipiell gibt es mehrere Designziele:</p>
<ul>
  <li>Möglichst hohe Geschwindigkeit beim Allozieren, Freigabe und Wiedereingliedern<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup></li>
  <li>Geringer Verschnitt</li>
  <li>Geringer Speicheroverhead</li>
</ul>

<p>Da wir nun leicht fremde Bibliotheken einbinden können, schauen wir uns mal auf <kbd>crates.io</kbd> um, ob sich nicht geeignete Algorithmen finden lassen. Und in der Tat gibt
es eine nahezu unüberschaubare Anzahl von Allokatoren. Jedoch sind die wenigsten davon <em>bare-metal</em>-geeignet, sondern dienen als Allokatoren für spezifische
(Betriebs-)Systeme oder Einsatzfälle.</p>

<p>Zu den <em>bare-metal</em>-tauglichen Allokatoren zählen:</p>
<ul>
  <li>Buddy-Allokator (siehe Vorlesung)</li>
  <li>Linked-List-Allokator: Freispeicher wird durch eine verlinkte Liste verwaltet</li>
  <li>Slab-Allokator: Vorhalten von vorgefertigten Speicherstückchen</li>
</ul>

<p>Obwohl er nicht das beste Laufzeitverhalten hat, werden ich vorläufig den Linked-List-Allokator verwenden. Dafür glänzt es mit einem Speicheroverhead und (internen)
Verschnitt von (nahezu) null.
Vielleicht werden ich ihn später ein zu einem
Boundary-Tag-Allokator überarbeiten, der ein besseres Zeitverhalten bei der Eingliederung hat (mit einem leicht erhöhten Overhead).</p>

<p>Meine <kbd>heap.rs</kbd> sieht jetzt so aus:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">linked_list_allocator</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::{</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cmp</span><span class="p">};</span>
<span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">linked_list_allocator</span><span class="p">::</span><span class="n">Heap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">sync</span><span class="p">::</span><span class="nn">no_concurrency</span><span class="p">::</span><span class="n">NoConcurrency</span><span class="p">;</span>

<span class="k">static</span> <span class="n">HEAP</span><span class="p">:</span> <span class="n">NoConcurrency</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Heap</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">NoConcurrency</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">init_heap</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span><span class="p">{</span><span class="n">HEAP</span><span class="nf">.set</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Heap</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">size</span><span class="p">)))};</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">aihpos_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">hpo</span> <span class="o">=</span> <span class="n">HEAP</span><span class="nf">.get</span><span class="p">();</span>
    <span class="k">match</span> <span class="o">*</span><span class="n">hpo</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">heap</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.allocate_first_fit</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">ret</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">ptr</span><span class="p">,</span>
                <span class="nb">None</span>  <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c">// ToDo: Reservierung zusätzlicher Seiten durch die logische Addressverwaltung =&gt; später</span>
                    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Out of memory"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Uninitialized heap"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">aihpos_deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">hpo</span> <span class="o">=</span> <span class="n">HEAP</span><span class="nf">.get</span><span class="p">();</span>
    <span class="k">match</span> <span class="o">*</span><span class="n">hpo</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">heap</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="n">heap</span><span class="nf">.deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="p">};</span>
        <span class="p">},</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Uninitialized heap"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="cp">#[allow(unused_variables)]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">aihpos_usable_size</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
   <span class="n">size</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="cp">#[allow(unused_variables)]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">aihpos_reallocate_inplace</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                                        <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
   <span class="n">size</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">aihpos_reallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                            <span class="n">align</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">new_ptr</span> <span class="o">=</span> <span class="nf">aihpos_allocate</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">ptr</span><span class="p">::</span><span class="k">copy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_ptr</span><span class="p">,</span> <span class="nn">cmp</span><span class="p">::</span><span class="nf">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">))</span> <span class="p">};</span>
    <span class="nf">aihpos_deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
    <span class="n">new_ptr</span>
<span class="p">}</span>


</code></pre>
</div>
<p>Im Quelltext sind die Stellen im Kommentar markiert, an denen später mit der Seitenverwaltung zusammengearbeitet werden soll.
Die Initialisierung erfolgt von <kbd>main.rs</kbd> aus. Dafür wird dort noch die initiale Heap-Größe festgelegt…</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span>  <span class="k">const</span> <span class="n">INIT_HEAP_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">;</span> <span class="c">// 25 Seiten = 100 kB</span>
</code></pre>
</div>
<p>…und die Heap-Initialisierung gerufen</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">init_heap</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">init_heap</span><span class="p">(</span><span class="n">__bss_start</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">INIT_HEAP_SIZE</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>
<p>Das Symbol <code class="highlighter-rouge">__bss_start</code> kommt aus <kbd>layout.ld</kbd>, die entsprechend überarbeitet werden muss. Es solle den Beginn des freien, also zu verwaltenden Speichers markieren.
Dann kann in <kbd>main.rs</kbd> das entsprechende externe Symbol deklarieren.
Hierbei nutze ich einen Trick: Da die externen Symbole ungetypt sind, erkläre ich es einfach zu einer Funktion:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">__bss_start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Damit kann die Funktionsadresse einfach in einen <code class="highlighter-rouge">usize</code> gewandelt werden. Wenn man statt dessen als Deklaration z.B.</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="p">{</span>
   <span class="k">static</span> <span class="n">__bss_start</span><span class="p">:</span> <span class="nb">u32</span><span class="p">;</span>
</code></pre>
</div>
<p>nehmen würde, wäre der Umwandlung komplexer und außerdem unsicher:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code>  <span class="nn">mem</span><span class="p">::</span><span class="nf">init_heap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">unsafe</span><span class="p">{</span><span class="n">__bss_start</span><span class="p">}</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">INIT_HEAP_SIZE</span><span class="p">);</span>
</code></pre>
</div>
<p>Allerdings kann die Deklaration so Verwirrung stiften; ich sollte vermutlich ein Makro als syntaktischen Zucker schreiben, dass einen aussagekräftigen Namen hat.
Schließlich ist gute Lesbarkeit ein Ziel in <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png">.</p>

<h2 id="vektoren-hashes--co">Vektoren, Hashes &amp; Co</h2>
<p>Und was hat man nun davon? Viel! Jetzt können einige Standardtypen von Rust genutzt werden, die uns bisher verschlossen waren. Dazu gehören:</p>
<ul>
  <li>Vektoren (Typ: <code class="highlighter-rouge">Vec&lt;T&gt;</code>)</li>
  <li>Queues (Typ: <code class="highlighter-rouge">VecDeque&lt;T&gt;</code> )</li>
  <li>Strings ohne fixe Länge (Typ: <code class="highlighter-rouge">String</code>)</li>
  <li>Mengen (Typ: <code class="highlighter-rouge">BTreeSet&lt;T&gt;</code>)</li>
</ul>

<p>und noch vieles mehr. Außerdem können jetzt explizit Daten auf den Heap gespeichert werden, was die (unsichere!) Nutzung von <code class="highlighter-rouge">static mut</code> weitgehend obsolet macht.
Um dies alles Nutzen zu können, müssen die beiden Crates <code class="highlighter-rouge">alloc</code> und <code class="highlighter-rouge">collections</code><sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup> eingebunden werden.</p>

<p>Allerdings ergibt die Einbindung der Crates mit</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">alloc</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">collctions</span><span class="p">;</span>
</code></pre>
</div>
<p>einen Compilerfehler:</p>
<div class="window">
          <nav class="control-window">
            <a href="#finder" class="close" data-rel="close">close</a>
            <a href="#" class="minimize">minimize</a>
            <a href="#" class="deactivate">deactivate</a>
          </nav>
          <h1 class="titleInside">Terminal</h1>
          <div class="container"><div class="terminal"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">$</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span></pre></td><td class="code"><pre><code><span class="line command">cargo kernel --target=arm-none-eabihf</span><span class="line output">   Compiling aihPOS v0.0.2 (file:///Users/mwerner/Development/aihPOS/aih_pos/kernel)
</span><span class="line output">error[E0463]: can't find crate for `alloc`
</span><span class="line output">  --&gt; src/main.rs:29:1
</span><span class="line output">   |
</span><span class="line output">29 | extern crate alloc;
</span><span class="line output">   | ^^^^^^^^^^^^^^^^^^^ can't find crate
</span><span class="line output">
</span><span class="line output">error: aborting due to previous error(s)
</span><span class="line output">
</span><span class="line output">error: Could not compile `aihPOS`.</span></code></pre></td></tr></table></div></div>
        </div>
<p>Ursache ist diesmal <code class="highlighter-rouge">xargo</code>. Es übersetzt standardmäßig nur <code class="highlighter-rouge">core</code>, aber nicht die anderen Bibliotheken. Um dies zur erreichen, muss man eine weitere Konfigurationsdatei
im Wurzelverzeichnis anlegen: <kbd>Xargo.toml</kbd>. Dort können zusätzliche Crates der Standard-Bibliothek angegeben werden:</p>
<div class="language-toml highlighter-rouge"><pre class="highlight"><code><span class="nn">[dependencies]</span>
<span class="py">alloc</span> <span class="p">=</span> <span class="err">{}</span>
<span class="py">collections</span> <span class="p">=</span> <span class="err">{}</span>
</code></pre>
</div>
<p>Nun funktioniert die Übersetzung reibungslos. Auch Codezeilen wie</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">collections</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="p">;</span>
<span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
</code></pre>
</div>
<p>sind jetzt möglich.</p>

<p>Damit haben wir eine vorläufige Lösung für die unterste Kernel-Schicht. Nebenbei werden uns auch viele Datenstrukturen geschenkt, die wir sonst in Schicht 2
implementieren müssten. Allerdings ist das Thema Speicher noch nicht erledigt: Speicher ist auch Betriebsmittel für die Prozesse. Hier kommt die logische
Speicherverwaltung ins Spiel, siehe die Diskussion oben. Aber das ist Thema des nächsten Beitrags in der <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png">-Reihe.</p>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/aihpos/2017/05/14/aihpos-umrustung/"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<p><a class="right button tiny radius r15" href="https://werner-matthias.github.io/SysOp/aihpos/2017/07/18/aihpos-braking-news/">Nächster Beitrag in AIHPOS<span class="icon-chevron-right"></span></a></p>

<div class="row"></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Das Verb heißt tatsächlich „allozieren“, siehe auch <a href="http://faql.de/fremdwort.html#allocate">hier</a>.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Achtung: Mitunter (auch in der ARM-Dokumentation) wird schon von „virtueller Speicherverwaltung“ gesprochen, wenn eine streuende Adressabbildung erfolgt. Hier wird
   „Virtualisierung“ aber im engeren Sinne verstanden, also so, dass mehr Ressourcen simuliert werden als vorhanden sind. Damit ist die Unterstützung der streuenden
   Adressierung nur ein Teil der Speichervirtualisierung.&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Es gibt noch mehr Möglichkeiten; hier werden nur die beiden wichtigsten Arten besprochen.&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Für den ARM ist das lediglich eine Konvention, die Hardware unterstützt auch Stacks, die nach oben wachsen.&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Es gibt zwar auch das Konzept eines fragmentierten Heaps, aber das ist relativ kompliziert zu implementieren und <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> soll ja einfach werden. :-)&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>Freigabe und Wiedereingliedern wird häufig zusammen erledigt.&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>Es gibt Bestrebungen, diese beiden Crates <a href="https://github.com/rust-lang/rust/issues/40475">zusammenzulegen</a>, derzeit sind sie aber noch getrennt.&nbsp;<a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

	                </span>
			
						<div id="page-meta" class="t30">
				<p>
					<!-- Look the author details up from the site config. -->
					
					<!-- Output author details if some exist. -->
					
					<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name" class="pr20 icon-edit"><a href="http://osg.informatik.tu-chemnitz.de/Staff/M_Werner/index.php?lang=en" target="_blank"> Matthias Werner</a></span>
				</span>
				

				
				<time class="icon-calendar pr20" datetime="2017-06-07" itemprop="datePublished"> 2017-06-07</time>
				

				<span class="icon-archive pr20"> AIHPOS</span>
				<br />
				<span class="pr20"><span class="icon-price-tag pr10"> aihPOS</span> <span class="icon-price-tag pr10"> Rust</span> <span class="icon-price-tag pr10"> Microkernel</span> <span class="icon-price-tag pr10"> Heap</span> <span class="icon-price-tag pr10"> Stack</span> </span>
			</p>

			<div id="post-nav" class="row">
				
				<div class="small-5 columns"><a class="button small radius prev" href="https://werner-matthias.github.io/SysOp/quotes/2017/05/21/computer-science/">&laquo; Computer Science</a></div><!-- /.small-4.columns -->
				
				<div class="small-2 columns text-center"><a class="radius button small" href="https://werner-matthias.github.io/SysOp/blog/archive/" title="Blog Archiv">Archiv</a></div><!-- /.small-4.columns -->
				
				<div class="small-5 columns text-right"><a class="button small radius next" href="https://werner-matthias.github.io/SysOp/meta/2017/06/19/hello-jekyll/">Hello Jekyll &raquo;</a></div><!-- /.small-4.columns -->
				
			</div>
			</div><!--  /.page-meta -->
			

	                
		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">Über diese Website</h5>

            <p class="shadow-black">
              Matthias Werners Blog. 
              <a href="https://werner-matthias.github.io/SysOp/info/">Mehr ›</a>
            </p>
          </div><!-- /.large-6.columns -->


          <div class="small-6 medium-3 large-3 large-offset-1 columns">
            
              
              <ul class="no-bullet shadow-black">
              
              </ul>
          </div><!-- /.large-4.columns -->


          <div class="small-6 medium-3 large-3 columns">
            
              
            <ul class="no-bullet shadow-black">
            
            </ul>
          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="https://werner-matthias.github.io/SysOp/assets/js/javascript.min.js"></script>














</body>
</html>

