<h1 id="rust-auf-nicht-standard-plattformen">Rust auf Nicht-Standard-Plattformen</h1>

<p>Nachdem ich im <a href="http://sysop.matthias-werner.net/?p=450">letzen Teil</a> schon wieder eine Bibliothek per Hand einpflegen musste, hatte ich beschlossen, auf das Rust-eigene Management-Tool <code class="highlighter-rouge">cargo</code> umzusteigen: Schließlich ist die Einbindung von externen Bibliotheken eine der Stärken von Rust. Dem gegenüber stehen für das SOPHIA-Projekt zwei Nachteile, die die Nutzung von <code class="highlighter-rouge">cargo</code> erschweren:</p>

<ul>
  <li>Unsere Zielplattform wird nicht unterstützt, damit auch nicht die entsprechenden Bibliotheken</li>
  <li>Das Endprodukt (Kernel-Image) ist „untypisch“. Seine Erstellung verlangt Post-Linker-Aktionen, die ebenfalls nicht unterstützt werden.</li>
</ul>

<p>Für beide Probleme gibt es (mindestens) eine Lösung.</p>

<h2 id="xargo">Xargo</h2>

<p>Zur Lösung des ersten Problems gibt es <a href="https://github.com/japaric/xargo"><code class="highlighter-rouge">xargo</code></a>, eine <code class="highlighter-rouge">cargo</code>-Variante für Cross-Umgebungen. Diese übersetzt automatisch die Core-Bibliothek und bei Bedarf auch andere Teile der Standard-Bibliothek und „schenkt“ dem Compiler die richtige Tool-Chain, indem <code class="highlighter-rouge">rootdir</code> entsprechend gesetzt wird. Man kann sich damit auch angepasste Versionen der Standard-Bibliothek erstellen — mal sehen, ob ich das später brauchen werde.</p>

<p>Die Installation geht dismal nicht über Homebrew, sondern schnell und reibungslos über <code class="highlighter-rouge">cargo</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cargo&amp;nbsp;install&amp;nbsp;xargo
</code></pre>
</div>

<p><code class="highlighter-rouge">Cargo</code>/<code class="highlighter-rouge">xargo</code> gehen von einem bestimmten Directory-Layout und der Existenz von (mindestens) einer Konfigurationsdatei <strong>cargo.toml</strong> aus, die das sogenannte „<a href="http://doc.crates.io/manifest.html">Manifest</a>“ enthält. Dort kann man auch benötigte Bibliotheken einbinden, die dann von <code class="highlighter-rouge">cargo</code> automatisch geladen und übersetzt werden. Wir wollten ja die <strong>compiler-buildins</strong>-Bibliothek nutzen. Dies geschieht im <strong>cargo.toml</strong> für unseren Kernel im Abschnitt <code class="highlighter-rouge">[dependencies]</code> und sieht so aus:</p>

<p>[package]
name = “aihPOS”
version = “0.0.2”
authors = [“Matthias Werner &lt;mwerner@informatik.tu-chemnitz.de&gt;”]</p>

<p>[dependencies]
compiler_builtins = { git = “https://github.com/rust-lang-nursery/compiler-builtins”, features = [“mem”] }</p>

<p>[profile.dev]
panic = “abort”
lto = false</p>

<p>[profile.release]
panic = “abort”
lto = false
opt-level = 3</p>

<p>Diese Datei muss sich im Wurzelverzeichnis eines Projekts oder Subprojekts befinden. Die Quelldateien sind dann in einem Unterverzeichnis <strong>src/</strong>, das weitere Verzeichnisse (mit ggf. eigenen <strong>cargo.toml</strong>-Dateien) befinden können. Beim Start einer Übersetzung mit <code class="highlighter-rouge">cargo build</code> wird ein Verzeichnis <strong>target</strong> angelegt,  in dem übersetzte Dateien etc. angelegt werden. </p>

<p>Neben dem Manifest gibt es optional noch eine Konfigurationsdatei, ebenfalls im TOML-Format. Sie heißt <strong>config</strong> und befindet sich in einem Unterverzeichnis <strong>.cargo/</strong>. Wir brauchen sie vor allem, weil die Erstellung des Kernels Compiler- bzw. Linkeroptionen benötigt, die nicht Standard sind:</p>

<p>[build]
traget= “arm-none-eabihf”</p>

<p>[target.arm-none-eabihf]
linker = “arm-none-eabi-gcc”
rustflags = [
  “-C”, “code-model=kernel”,
  “-C”, “link-arg=-nostartfiles”,
  “-C”, “link-arg=-nostdlib”,
  “-C”, “link-arg=-Tlayout.ld”,
  “-C”, “link-arg=-mfloat-abi=hard”,
  “-C”, “link-arg=-ffreestanding”,
  ]</p>

<p>Die Trennung der Steuerung von Compiler-Optionen (in den <code class="highlighter-rouge">[profile.*]</code>-Abschnitten in <strong>cargo.toml</strong> können auch einige Optionen gesteuert werden) ist etwas unglücklich und wird möglicherweise in künftigen Rust/Cargo-Versionen aufgehoben, aber derzeit muss man damit leben.</p>

<h2 id="post-linker-aktionen">Post-Linker Aktionen</h2>

<p>Wenn man sich das bisherige <strong>Makefile</strong> anschaut, dann sieht man, dass der Building-Prozess nicht — wie sonst meist üblich — mit dem Linken endet. Dies ist in <code class="highlighter-rouge">cargo</code> nicht vorgesehen. Zwar kennt <code class="highlighter-rouge">cargo</code> die Möglichkeit, mit Hilfe eines Build-Scriptes Schritte <strong>vor</strong> der Übersetzung auszuführen; etwas ähnliches für danach wird zwar in unter den Entwicklern diskutiert, wurde aber bisher nicht umgesetzt. Man kann zwar den Linker (in der Target-Datei) umdefinieren, aber ich fürchte, dass eine solche Lösung schnell unübersichtlich wird. Es ein häufig genutzter und sogar empfohlener1 Ansatz ist daher,  <code class="highlighter-rouge">cargo</code> wiederum von einem <code class="highlighter-rouge">Makefile</code> aufrufen lassen. Das würde aber  dazu führen, dass Abhängigkeiten z.T. doppelt gepflegt werden müssen. Wenn <code class="highlighter-rouge">cargo</code>, dann richtig. </p>

<p>Glücklicherweise ist <code class="highlighter-rouge">cargo</code> leicht erweiterbar: Wenn <code class="highlighter-rouge">cargo</code> (oder <code class="highlighter-rouge">xargo</code>) mit einem unbekannten Befehl gerufen wird, sucht es im Standardpfad nach einem Programm <code class="highlighter-rouge">cargo-</code>. Dass mache ich mir zunutze und schreibe ein kleines <code class="highlighter-rouge">bash</code>-Skript <code class="highlighter-rouge">cargo-kernel</code>, das erst <code class="highlighter-rouge">xargo</code> aufruft und dann noch den „Rest“ erledigt:</p>

<p>shift
PROFILE=debug
TARGET=
for opt in “$@”; do
    case $opt in
        –release)
		PROFILE=release
     		;;
	–target=*)
		TARGET=<code class="highlighter-rouge">echo $opt | cut -f2 -d'='</code> 
    esac
done
BINPATH=./target/$TARGET/$PROFILE
xargo build $@
PKG=<code class="highlighter-rouge">xargo pkgid -q | cut -d# -f2 | cut -d: -f1</code>
if [ -a $BINPATH/$PKG ]; then
   arm-none-eabi-objcopy $BINPATH/$PKG -O binary  $BINPATH/kernel.img
   arm-none-eabi-objdump -D $BINPATH/$PKG &gt; $BINPATH/$PKG.list
fi</p>

<p>Diese Skript muss irgendwo im Ausführungsfad abgelegt werden. Dann kann man die Übersetzung im Rust-Stil anstoßen:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cargo&amp;nbsp;kernel&amp;nbsp;--target=arm-none-eabihf
  
  
  
  Compiling&amp;nbsp;core&amp;nbsp;v0.0.0&amp;nbsp;(file:///Users/mwerner/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/src/libcore)
  
  
  
   Finished&amp;nbsp;release&amp;nbsp;[optimized]&amp;nbsp;target(s)&amp;nbsp;in&amp;nbsp;22.87&amp;nbsp;secs
  
  
  
  Compiling&amp;nbsp;compiler_builtins&amp;nbsp;v0.1.0&amp;nbsp;(https://github.com/rust-lang-nursery/compiler-builtins#f3ace110)
  
  
  
  Compiling&amp;nbsp;aihPOS&amp;nbsp;v0.0.2&amp;nbsp;(file:///Users/mwerner/Development/aihPOS/aih_pos/kernel)
  
  
  
warning:&amp;nbsp;crate&amp;nbsp;`aihPOS`&amp;nbsp;should&amp;nbsp;have&amp;nbsp;a&amp;nbsp;snake&amp;nbsp;case&amp;nbsp;name&amp;nbsp;such&amp;nbsp;as&amp;nbsp;`aih_pos`
  
  
  
  |
  
  
  
  =&amp;nbsp;note:&amp;nbsp;#[warn(non_snake_case)]&amp;nbsp;on&amp;nbsp;by&amp;nbsp;default
  
  
  
 Finished&amp;nbsp;dev&amp;nbsp;[optimized&amp;nbsp;+&amp;nbsp;debuginfo]&amp;nbsp;target(s)&amp;nbsp;in&amp;nbsp;4.8&amp;nbsp;secs
</code></pre>
</div>

<p>Man beachte, dass immer noch <code class="highlighter-rouge">cargo</code> und nicht <code class="highlighter-rouge">xargo</code> aufgerufen werden muss. Zwar würde auch <code class="highlighter-rouge">xargo</code> das Shellskript finden und ausführen, jedoch hat <code class="highlighter-rouge">cargo</code>/<code class="highlighter-rouge">xargo</code> einen Lock, der die nebenläufige Ausführung blockiert. <code class="highlighter-rouge">xargo kernel</code> würde also hängen bleiben.</p>

<h2 id="diskussion">Diskussion</h2>

<p>Bin ich nun vollständig in der Rust-Welt angekommen? Das hängt von der Betrachtung ab. Ich kann auf <code class="highlighter-rouge">make</code> verzichten und alles, was ich mit <code class="highlighter-rouge">make</code> gemacht habe nun mit Rust-Mitteln tun. Andererseits kennt <code class="highlighter-rouge">cargo</code> noch viele Befehle  — wie z.B. für das Bauen von Tests und Dokumentationen oder die Arbeit mit Repositories — die noch nicht berücksichtigt sind. Einiges könnte einfach so funktionieren, aber es besteht dafür keine Garantie.</p>

<h1 id="github">GitHub</h1>

<p>Wenn ich schon bei einer Reorganisation bin, gehe ich noch einen Schritt weiter: Der alte JTAG-Kernel (siehe <a href="http://sysop.matthias-werner.net/?p=307">Teil 3</a>) kommt in ein eigenes Verzeichnis, so dass er noch immer mit <code class="highlighter-rouge">make</code> übersetzt werden kann. Ich nutze ihn als Boot-Kernel, so dass ich Änderungen im Entwicklungskernel schnell über das JTAG-Interface laden und testen kann.</p>

<p>Außerdem habe ich ein <a href="https://github.com/werner-matthias/aihPOS">GitHub-Projekt</a> für SOPHIA aufgesetzt. Dort kann der komplette Quellcode abgerufen werden.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  Die cargo-Entwickler betonen immer wieder, dass cargo kein komplettes Build-Management-Tool ist und auch nicht sein will. &amp;#8629;
</code></pre>
</div>

