<p>Nachdem wir unsere <a href="http://sysop.matthias-werner.net/ein-betriebssystem-fuer-die-lehre-teil-2/">Toolchain</a> installiert haben, wollen wir den ersten „Kernel“ bauen. Er soll nichts anderes machen, als den Pi für JTAG vorbereiten. Dafür müssen wir uns mit Details unserer Plattform herumschlagen, insbesondere mit der Beschreibung der <a href="https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">I/O-Hardware</a>, dem Speicher-Layout und dem Boot-Prozess.</p>

<h1 id="boot-prozess">Boot-Prozess</h1>

<p>Unsere ARM-CPU ist nicht die einzige CPU auf dem Raspberry. Vielmehr gibt es einen weiteren Prozessor, die <a href="https://docs.broadcom.com/docs/12358545">GPU VideoCore</a>® IV. Anders als die Bezeichnung vermuten lässt, ist die GPU nicht nur für die Grafiksteuerung verantwortlich, sondern übernimmt z.B. auch den Boot-Prozess.1 Wenn der Strom eingeschaltet wird, übernimmt erst mal die GPU die Regie. Sie bootet von einem internen ROM, lädt dann von der SD-Karte die Datei bootcode.bin. Diese kann enthält einen Treiber, um Dateien im ELF-Format lesen. Als nächstes wird die eigentliche GPU-Firmware aus der Datei start.elf geladen. Die Firmware liest u.a. die Datei config.txt (so vorhanden) und konfiguriert das Board entsprechend, und lädt anschließend die Datei kernel.img auf die (aus AMR-Sicht) Adresse 0x08000. Von dieser Adresse aus startet dann auch der ARM.</p>

<h1 id="speicher-und-formate">Speicher und Formate</h1>

<h2 id="layout-und-linker">Layout und Linker</h2>

<p>Die Datei kernel.img ist ein Binärfile, das unmittelbar Maschinencode enthält, also keine ELF-Datei oder ein anderes höheres Format. Wir müssen also erstens dafür sorgen, dass unser „Kernel“ von der Adresse 0x08000 lauffähig ist, und zweitens, dass er als reine Binärdatei vorliegt. Beim ersten hilft der Linker. In der „normalen“ Softwareentwicklung bekommt man vom Linker nicht viel mit, er macht ohne viel Aufsehen das, was man von ihm erwartet. Da wir hier aber ganz bestimmte Anforderungen haben, müssen wir es ihm mit einem <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">Linker-Skript</a> mitteilen. Unser Linker-Skript ist (noch) sehr einfach:</p>

<p>ENTRY(kernel_main)
SECTIONS
{
    /* Starts at LOADER_ADDR. <em>/
    . = 0x8000;
    .text :
    {
        KEEP(</em>(.text.kernel_main))
        *(.text)
    }	
    .bss :
    {
        bss = .;
        *(.bss)
    }
}</p>

<p>Es sagt im Wesentlichen, dass unsere Einsprungstelle in den Code kernel_main heißt,2 und dass der Code an Adresse 0x0800 beginnt und zwar mit kernel_main.</p>

<h2 id="binärfile">Binärfile</h2>

<p>Um aus dem vom Linker generierten ELF-File ein Binärfile zu machen, nutzen wir <a href="https://sourceware.org/binutils/docs/binutils/objcopy.html#objcopy"><code class="highlighter-rouge">objcopy</code></a>, genauer die Cross-Variante arm-none-eabi-objcopy. Der Name objcopy ist ein klares Understatement, das dieses Programm nicht nur kopiert, sondern eine Vielzahl von Transformationen ausführen kann. Wir nutzen es allerdings nur dazu, aus dem ELF-File den Binärcode zu generieren, eine Aufgabe, die auf Plattformen <em>mit</em> einem Betriebssystem i.d.R. der Lader übernimmt.</p>

<h2 id="makefile">Makefile</h2>

<p>Eigentlich hat Rust sein eigenes Build-System <code class="highlighter-rouge">cargo</code>, mit dem wir schon die core-Bibliothek gebaut haben. Jedoch ist <code class="highlighter-rouge">cargo</code> nicht sonderlich gut für bare-metal Programme geeignet. Daher werden wir auf die klassische Form des Makefiles zurückgreifen.3</p>

<p>Unser Makefile geht davon aus, dass wir folgendes Verzeichnis-Layout haben:</p>

<p>aihpos
  |
  +- rust-corelib
  |
  +- jtag
      |
      +– src
      +– obj
      +– build</p>

<p>In src sind alle Quelldateien. Die Objektdateien liegen in obj und alle anderen generierten Dateien in build. Das Makefile selbst befindet sich in jtag und sieht so aus:</p>

<p>BUILDDIR=build
SRCDIR=src
OBJDIR=obj
BUILDDIR=build
OBJCOPY=arm-none-eabi-objcopy
OBJDUMP=arm-none-eabi-objdump
RUSTC=rustc
LIBCORE=../rust-libcore/target/arm-none-eabihf/release/libcore.rlib
RUSTFLAGS= –target $(TARGET) -C panic=abort -g –crate-type staticlib –extern core=$(LIBCORE)
LINKFLAGS= -O0 -g -Wl,-gc-sections -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -nostdlib</p>

<p>TARGET=arm-none-eabihf
MAIN=kernel</p>

<p>IMAGE=$(BUILDDIR)/$(MAIN).img
LIST=$(BUILDDIR)/$(MAIN).list
ELF=$(BUILDDIR)/$(MAIN).elf</p>

<p>vpath %.rs $(SRCDIR)
vpath %.o $(OBJDIR)</p>

<p>SOURCES= main.rs 
OBJ= $(addsuffix .o, $(basename $(SOURCES)))</p>

<p>.PHONY: clean</p>

<p>all: $(IMAGE) $(LIST)</p>

<p>main.o:	main.rs panic.rs</p>

<p>$(IMAGE): $(ELF)
	$(OBJCOPY) $(ELF) -O binary $(IMAGE)</p>

<p>$(LIST): $(IMAGE)
	$(OBJDUMP) -d $(ELF) &gt; $@</p>

<p>$(ELF): $(OBJ) 
	arm-none-eabi-gcc $(LINKFLAGS) -Tsrc/layout.ld  $(addprefix $(OBJDIR)/, $(OBJ)) -o $@</p>

<p>%.o: %.rs 
	$(RUSTC) $(RUSTFLAGS) $&lt; -o $(OBJDIR)/$@</p>

<p>clean:
	rm -f $(OBJDIR)/*
	rm -f $(BUILDDIR)/*</p>

<p>Nach der Diskussion dürfte es nicht weiter überraschend sein. Einzig das Ziel LIST haben wir noch nicht besprochen. Dies ist der mit Hilfe von objdump disassemblierte Code des erzeugten ELF-Files. Er kann manchmal bei der Fehlersuche nützlich sein.</p>

<h1 id="hardware">Hardware</h1>

<h2 id="jtag">JTAG</h2>

<p>Der Pi hat 54  universelle Kommunikationspins, die als Ausgabe (Standard beim Einschalten), Eingabe oder mit jeweils bis zu sechs Spezialfunktionen (Alternativfunktionen 0…5) beschaltet werden kann. Für JTAG werden fünf Steuerleitungen gebraucht, die jeweils auf zwei verschiedene Pins</p>

<ul>
  <li>Data Input (<em>TDI</em>), serieller Eingang, auf Pin 4 in der Alternativfunktion 5 oder Pin 26  in der Alternativfunktion 4</li>
  <li>Test Data Output (<em>TDO</em>), serieller Ausgang,  auf Pin 5 in der Alternativfunktion 5 oder Pin 24  in der Alternativfunktion 4</li>
  <li>Test Clock (<em>TCK</em>). Das Taktsignal,  auf Pin 13 in der Alternativfunktion 5 oder Pin 25  in der Alternativfunktion 4</li>
  <li>Test Mode Select (<em>TMS</em>), Steuerleitung, auf Pin 12 in der Alternativfunktion 5 oder Pin 27  in der Alternativfunktion 4</li>
  <li>Test Reset (<em>TRST</em>), Reset, auf Pin 12 in der Alternativfunktion 5 oder Pin 22  in der Alternativfunktion 4</li>
</ul>

<p>Der Adapter (siehe letzter Beitrag) nutzt die Pin 22 bis 27, entsprechen müssen diese auf Alternativfunktion 4 gesetzt werden. Dies geschieht über die GPIO-Select-Register, genauer über GPIOSEL2. Jeweils drei aufeinanderfolgende Bits wählen die Funktion für ein GPIO-Pin aus.</p>

<p>Außerdem muss vorher für diese Pins die Pull-up/down-Steuerung deaktiviert werden. Dabei folgen wir der Beschreibung auf Seite 101 die ARM-Peripherie-Dokumentation.</p>

<h2 id="led">LED</h2>

<p>Damit wir sehen, dass unser Programm auch läuft, wollen wir die grüne LED des Raspberrys blinken lassen. Diese ist an den GPIO-Pin 47 angeschlossen. Die GPIO-Pins sind in zwei Sätze unterteilt, Satz 1 für Pin 0…31, und Satz 2 für Pin 32…53. Pin 47 ist also Pin 15 (wenn man mit Null anfängt zu zählen) des zweiten Satzes.</p>

<h1 id="software">Software</h1>

<h2 id="das-erste-rust-programm">Das erste Rust-Programm</h2>

<p>Wir haben jetzt alle Informationen zusammen, um eine Software zu schreiben, die den Raspberry auf einen JTAG-Zugriff vorzubereiten. Wie schon im <a href="http://sysop.matthias-werner.net/aihpos-ein-betriebssystem-fuer-die-lehre-teil-1/">Teil 1 dieser Reihe</a> diskutiert, soll Rust benutzt werden, mit — wenn nötig — etwas Assembler. In der Regel wird der Startup-Code in Assembler geschrieben, siehe z.B. <a href="http://wiki.osdev.org/Raspberry_Pi_Bare_Bones">hier</a>. Das ist im Allgemeinen auch eine gute Idee: jede Rust-Funktion (oder C-Funktion) hat einen Prolog, in dem die Rücksprungadresse auf dem Stack gesichert wird. Allerdings ist zu Beginn ja noch gar kein Stack angelegt. Dies und andere Initialisierungen macht das Assemblerprogramm, ehe es in den in der höheren Programmiersprache geschriebenen Code ruft.</p>

<p>Allerdings ist ein solches Assembler-Modul in unserem Fall nicht nötig: Einerseits können wir Assembler-Befehle direkt in den Rust-Code einbetten, andererseits können wir unsere Startfunktion mit dem Attribute #[naked] versehen, so dass der Compiler keinen Prolog oder Epilog anlegt.</p>

<p>#![feature(asm,lang_items,core_intrinsics,naked_functions)]
#![no_std]</p>

<p>// Hardware-Adressen
const GPIO_BASE: u32 = 0x20200000;
const GPFSEL2:    *mut u32 = (GPIO_BASE+0x08) as *mut u32;
const GPSET1:     *mut u32 = (GPIO_BASE+0x20) as *mut u32;
const GPCLR1:     *mut u32 = (GPIO_BASE+0x2C) as *mut u32;
const GPPUD:      *mut u32 = (GPIO_BASE+0x94) as *mut u32;
const GPPUDCLK0:  *mut u32 = (GPIO_BASE+0x98) as *mut u32;</p>

<p>fn sleep(value: u32) {<br />
    for _ in 1..value {
        unsafe { asm!(“”); }  // Hack: Compiler kann Schleife nicht wegoptimieren
    }
}</p>

<p>#[no_mangle]   // Name wird für den Export nicht verändert
#[naked]       // keinen Prolog
pub extern fn kernel_main() {
    // Setze den Stackpointer
    unsafe{ asm!(“mov sp, #0x8000”);  }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Pull up/down abschalten
unsafe{ *GPPUD = 0 };
sleep(150);
unsafe{ *GPPUDCLK0 = (1 &amp;lt;&amp;lt; 22) | (1 &amp;lt;&amp;lt; 23) | (1 &amp;lt;&amp;lt; 24) | (1 &amp;lt;&amp;lt; 25) | (1 &amp;lt;&amp;lt; 26) | (1 &amp;lt;&amp;lt; 27) };
sleep(150);
unsafe{ *GPPUDCLK0 = 0 };

// GPIO Pins 22 .. 27 auf alternative Funktion 4 (= 011) setzen
let mut selection: u32 = unsafe{ *GPFSEL2};
selection = selection &amp; !((0b111 &amp;lt;&amp;lt;  6)  | (0b111 &amp;lt;&amp;lt;  9) | (0b111 &amp;lt;&amp;lt;  12) | (0b111 &amp;lt;&amp;lt;  15) | (0b111 &amp;lt;&amp;lt;  18) | (0b111 &amp;lt;&amp;lt;  21) );
selection = selection | (0b011 &amp;lt;&amp;lt;  6) | (0b011 &amp;lt;&amp;lt; 9) | (0b011 &amp;lt;&amp;lt;  12) | (0b011 &amp;lt;&amp;lt;  15) | (0b011 &amp;lt;&amp;lt;  18) | (0b011 &amp;lt;&amp;lt;  21);
unsafe {  *GPFSEL2 = selection};

// Als Lebenszeichen lassen wir die grüne LED blinken
let led_on  = GPSET1;
let led_off = GPCLR1; 
loop {
    unsafe { *(led_on) = 1 &amp;lt;&amp;lt; 15; }
    sleep(50000);
    unsafe { *(led_off) = 1 &amp;lt;&amp;lt; 15; }
    sleep(50000);
} } 
</code></pre>
</div>

<h2 id="panik">Panik!</h2>

<p>Nun übersetzen wir dieses Programm.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make
  
  
  
rustc&amp;nbsp;--target&amp;nbsp;arm-none-eabihf&amp;nbsp;-C&amp;nbsp;panic=abort&amp;nbsp;-g&amp;nbsp;--crate-type&amp;nbsp;staticlib&amp;nbsp;--extern&amp;nbsp;core=../rust-libcore/target/arm-none-eabihf/release/libcore.rlib&amp;nbsp;src/main.rs&amp;nbsp;-o&amp;nbsp;build/main.o
  
  
  
error:&amp;nbsp;language&amp;nbsp;item&amp;nbsp;required,&amp;nbsp;but&amp;nbsp;not&amp;nbsp;found:&amp;nbsp;`panic_fmt`
  
  
  
error:&amp;nbsp;aborting&amp;nbsp;due&amp;nbsp;to&amp;nbsp;previous&amp;nbsp;error
  
  
  
make:&amp;nbsp;***&amp;nbsp;[main.o]&amp;nbsp;Error&amp;nbsp;101
</code></pre>
</div>

<p>Hoppla! Der Linker hat ein undefiniertes Symbol. Ursache dafür ist, dass die Core-Bibliothek nicht völlig frei von externen Referenzen ist. Tust muss wissen, wie es sich in einem Ausnahmefall (Exception) verhalten soll, um evtl. sogar eine Recovery zu ermöglichen, und das ist plattform-spezifisch. Wenn allerdings wie in unserem Fall der der „Kernel“ selbst crashed, ist eine Recovery hoffnungslos. Es ist daher hinreichend, die undefinierten Symbole (es sind nämlich noch ein paar) einfach durch Dummy-Funktionen zu definieren. Dazu legen wir noch eine Datei panic.rs an:</p>

<p>use core::intrinsics;</p>

<p>#[lang = “eh_personality”] extern fn eh_personality() {}</p>

<p>#[no_mangle]
pub extern fn __aeabi_unwind_cpp_pr0() -&gt; ()
{
 loop {}
}</p>

<p>#[no_mangle]
pub extern fn __aeabi_unwind_cpp_pr1() -&gt; ()
{
 loop {}
}</p>

<p>#[allow(non_snake_case)] #[no_mangle]
pub extern “C” fn _Unwind_Resume() -&gt; ! {
 loop {}
}</p>

<p>#[lang = “panic_fmt”]
#[no_mangle]
pub extern fn rust_begin_panic(_msg: core::fmt::Arguments, 
                               _file: &amp;’static str,
                               _line: u32) -&gt; ! {
 unsafe { intrinsics::abort() }
}</p>

<p>Außerdem fügen wir main.rs noch eine Zeile hinzu:</p>

<p>include!(“panic.rs”);</p>

<p>Dieses Macro funktioniert ähnlich wie das <code class="highlighter-rouge">#include</code> in C und macht die Datei panic.rs logisch zu einem Bestandteil von main.rs. Dieses Vorgehen ist ein bisschen „unrustig“, da eigentlich in Rust kein Modul in mehr als einer Datei sein soll (dafür ruhig mehrere Module in einer Datei), aber ich habe diese Variante gewählt, um den eigentlichen Funktionscode halbwegs „rein“ zu halten ohne extra ein neues Modul anlegen zu müssen. Nun läuft die Übersetzung durch. Anschließend kopieren wir da Binär-Image auf die SD-Karte,</p>

<div class="highlighter-rouge"><pre class="highlight"><code> make
  
  
  
rustc&amp;nbsp;--target&amp;nbsp;arm-none-eabihf&amp;nbsp;-C&amp;nbsp;panic=abort&amp;nbsp;-g&amp;nbsp;--crate-type&amp;nbsp;staticlib&amp;nbsp;--extern&amp;nbsp;core=../rust-libcore/target/arm-none-eabihf/release/libcore.rlib&amp;nbsp;src/main.rs&amp;nbsp;-o&amp;nbsp;obj/main.o
  
  
  
arm-none-eabi-gcc&amp;nbsp;-O0&amp;nbsp;-g&amp;nbsp;-Wl,-gc-sections&amp;nbsp;-mfpu=vfp&amp;nbsp;-mfloat-abi=hard&amp;nbsp;-march=armv6zk&amp;nbsp;-mtune=arm1176jzf-s&amp;nbsp;-nostdlib&amp;nbsp;-Tsrc/layout.ld &amp;nbsp;obj/main.o&amp;nbsp;-o&amp;nbsp;build/kernel.elf
  
  
  
arm-none-eabi-objcopy&amp;nbsp;build/kernel.elf&amp;nbsp;-O&amp;nbsp;binary&amp;nbsp;build/kernel.img
  
  
  
arm-none-eabi-objdump&amp;nbsp;-d&amp;nbsp;build/kernel.elf&amp;nbsp;&gt;&amp;nbsp;build/kernel.list
  
  
  
cp&amp;nbsp;build/kernel.img&amp;nbsp;/Volume/boot/
</code></pre>
</div>

<p>Wenn der Raspberry mit dieser SD gestartet wird, fängt die grüne LED tatsächlich an zu blinken.</p>

<h1 id="mit-dem-pireden">Mit dem Pi reden</h1>

<p>Jetzt soll die JTAG-Lommunikation getestet werden. Dazu schreiben wir zwei openocd-Konfigurationsdateien4:</p>

<p>interface jlink</p>

<h1 id="broadcom-2835-on-raspberry-pi">Broadcom 2835 on Raspberry Pi</h1>
<p>telnet_port 4444
gdb_port 3333
adapter_khz 0</p>

<p>if { [info exists CHIPNAME] } {
set _CHIPNAME $CHIPNAME
} else {
set _CHIPNAME raspi
}</p>

<p>reset_config none</p>

<p>if { [info exists CPU_TAPID ] } {
set _CPU_TAPID $CPU_TAPID
} else {
set _CPU_TAPID 0x07b7617F
}
jtag newtap $_CHIPNAME arm -irlen 5 -expected-id $_CPU_TAPID</p>

<p>set _TARGETNAME $_CHIPNAME.arm
target create $_TARGETNAME arm11 -chain-position $_TARGETNAME</p>

<p>In einem Terminal kann jetzt der OpenOCD-Server gestartet werden:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>openocd&amp;nbsp;-f&amp;nbsp;jlink.cfg&amp;nbsp;-f&amp;nbsp;raspi.cfg
  
  
  
Open&amp;nbsp;On-Chip&amp;nbsp;Debugger&amp;nbsp;0.10.0+dev-00093-g6b2acc0&amp;nbsp;(2017-03-28-11:17)
  
  
  
Licensed&amp;nbsp;under&amp;nbsp;GNU&amp;nbsp;GPL&amp;nbsp;v2
  
  
  
For&amp;nbsp;bug&amp;nbsp;reports,&amp;nbsp;read
  
  
  
http://openocd.org/doc/doxygen/bugs.html
  
  
  
adapter&amp;nbsp;speed:&amp;nbsp;1000&amp;nbsp;kHz
  
  
  
none&amp;nbsp;separate
  
  
  
Info&amp;nbsp;:&amp;nbsp;auto-selecting&amp;nbsp;first&amp;nbsp;available&amp;nbsp;session&amp;nbsp;transport&amp;nbsp;&amp;#8222;jtag&amp;#8220;.&amp;nbsp;To&amp;nbsp;override&amp;nbsp;use&amp;nbsp;&amp;#8218;transport&amp;nbsp;select&amp;nbsp;&amp;#8218;.
  
  
  
raspi.arm
  
  
  
Info&amp;nbsp;:&amp;nbsp;No&amp;nbsp;device&amp;nbsp;selected,&amp;nbsp;using&amp;nbsp;first&amp;nbsp;device.
  
  
  
Info&amp;nbsp;:&amp;nbsp;J-Link&amp;nbsp;V10&amp;nbsp;compiled&amp;nbsp;Jan&amp;nbsp;9&amp;nbsp;2017&amp;nbsp;17:48:51
  
  
  
Info&amp;nbsp;:&amp;nbsp;Hardware&amp;nbsp;version:&amp;nbsp;10.10
  
  
  
Info&amp;nbsp;:&amp;nbsp;VTarget&amp;nbsp;=&amp;nbsp;3.335&amp;nbsp;V
  
  
  
Info&amp;nbsp;:&amp;nbsp;clock&amp;nbsp;speed&amp;nbsp;1000&amp;nbsp;kHz
  
  
  
Info&amp;nbsp;:&amp;nbsp;JTAG&amp;nbsp;tap:&amp;nbsp;raspi.arm&amp;nbsp;tap/device&amp;nbsp;found:&amp;nbsp;0x07b7617f&amp;nbsp;(mfg:&amp;nbsp;0x0bf&amp;nbsp;(Broadcom),&amp;nbsp;part:&amp;nbsp;0x7b76,&amp;nbsp;ver:&amp;nbsp;0x0)
  
  
  
Info&amp;nbsp;:&amp;nbsp;found&amp;nbsp;ARM1176
  
  
  
Info&amp;nbsp;:&amp;nbsp;raspi.arm:&amp;nbsp;hardware&amp;nbsp;has&amp;nbsp;6&amp;nbsp;breakpoints,&amp;nbsp;2&amp;nbsp;watchpoints
</code></pre>
</div>

<p>Nun kann ein weiteres Terminalfenster geöffnet werden, in dem ein Telnet gestartet wird.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>telnet&amp;nbsp;localhost&amp;nbsp;4444
  
  
  
Connected&amp;nbsp;to&amp;nbsp;localhost.
  
  
  
Escape&amp;nbsp;character&amp;nbsp;is&amp;nbsp;&amp;#8218;^]&amp;#8216;.
  
  
  
Open&amp;nbsp;On-Chip&amp;nbsp;Debugger
  
  
  
&gt;&amp;nbsp;halt
  
  
  
target&amp;nbsp;halted&amp;nbsp;in&amp;nbsp;ARM&amp;nbsp;state&amp;nbsp;due&amp;nbsp;to&amp;nbsp;debug-request,&amp;nbsp;current&amp;nbsp;mode:&amp;nbsp;Supervisor
  
  
  
cpsr:&amp;nbsp;0x600001d3&amp;nbsp;pc:&amp;nbsp;0x000082e0
  
  
  
&gt;
</code></pre>
</div>

<p>Jetzt kann man viele interessante Dinge machen. Beispielsweise können Register ausgelesen oder Speicherstellen gelesen oder geschrieben werden:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt;&amp;nbsp;reg&amp;nbsp;r1
  
  
  
r1&amp;nbsp;(/32):&amp;nbsp;0x00007FD4
  
  
  
&gt;&amp;nbsp;mww&amp;nbsp;0x2020002C&amp;nbsp;0x8000
  
  
  
&gt;&amp;nbsp;mww&amp;nbsp;0x20200020&amp;nbsp;0x8000
</code></pre>
</div>

<p>Die letzten beiden Befehle schalten die grüne LED aus- und wieder an. Der vermutlich wichtigste Befehl ist aber load_image. Damit entfällt das Kopieren eines neuen Images auf die SD-Karte. Die Datei (wahlweise auch im ELF-Format) kann direkt auf den Pi gebracht werden.</p>

<p>Für ein noch etwas detaillierteres Debuggen kann openocd mit dem GNU-Debugger gekoppelt werden. Im Konfigurationsfile wurde der Port 3333 dafür freigegeben. Natürlich darf nicht der lokale Debugger genutzt werden5, sondern der ARM-Cross-Debugger:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arm-none-eabi-gdb&amp;nbsp;-q&amp;nbsp;build/kernel.elf
  
  
  
Reading&amp;nbsp;symbols&amp;nbsp;from&amp;nbsp;build/kernel.elf&amp;#8230;done.
  
  
  
(gdb)&amp;nbsp;target&amp;nbsp;remote&amp;nbsp;localhost:3333
  
  
  
Remote&amp;nbsp;debugging&amp;nbsp;using&amp;nbsp;localhost:3333
  
  
  
0x000082e0&amp;nbsp;in&amp;nbsp;core::mem::swap&amp;nbsp;(x=0x7f98,&amp;nbsp;y=0x7fd4)&amp;nbsp;at&amp;nbsp;~/Development/aihPOS/Code/rust-libcore/rust/src/libcore/mem.rs:448
  
  
  
448&amp;nbsp;pub&amp;nbsp;fn&amp;nbsp;swap(x:&amp;nbsp;&amp;mut&amp;nbsp;T,&amp;nbsp;y:&amp;nbsp;&amp;mut&amp;nbsp;T)&amp;nbsp;{
</code></pre>
</div>

<p>Wer will, kann den Debugger auch in eine GUI oder IDE einbinden, z.B. mit der</p>

<p><a href="https://pypi.python.org/pypi/gdbgui/"><code class="highlighter-rouge">gdbgui</code></a>.</p>

<p><a href="http://sysop.matthias-werner.net/wp-content/uploads/2017/04/debug.png"></a>Nun kann man auch ohne Betriebssystem (fast) so bequem debuggen, wie man es von der Entwicklung von Desktop-Programmen gewohnt ist. Zwar ist die Arbeit über das JTAG-Interface etwas langsam, aber immer noch viel schneller als wenn man ständig die SD-Karte wechselt.</p>

<h2 id="morsezeichen">Morsezeichen</h2>

<p>Manchmal will man eine schnelle Rückmeldung haben, ob eine bestimmte Stelle im Programm erreicht wurde oder ob ein Fehler aufgetreten ist. Solange wir keine Konsole haben, können wir die LED dafür nutzen. Dazu wird unser Blinkprogramm in ein eigenes Modul ausgelagert und parameterisiert:</p>

<p>#![allow(dead_code)]
// Hardware-Adressen
const GPIO_BASE: u32 = 0x20200000;
const GPSET1: *mut u32 = (GPIO_BASE+0x20) as *mut u32;
const GPCLR1: *mut u32 = (GPIO_BASE+0x2C) as *mut u32;</p>

<p>#[derive(Clone,Copy)]
#[repr(u32)]
pub enum Bc {
    Long =  75000,
    Short = 25000,
    Pause = 50000,
}</p>

<p>type BlinkSeq = &amp;’static [Bc];</p>

<p>/* Blinksequenzen */
// einmal blinken
pub const BS_DUMMY: BlinkSeq =   &amp;[Bc::Long];
// Lang, dann ein-, zwei, oder dreimal kurz
pub const BS_ONE: BlinkSeq   =   &amp;[Bc::Long,Bc::Short];
pub const BS_TWO: BlinkSeq   =   &amp;[Bc::Long,Bc::Short,Bc::Short];
pub const BS_THREE: BlinkSeq =   &amp;[Bc::Long,Bc::Short,Bc::Short,Bc::Short];
// SOS (für Panik, wenn keine Konsole zur Verfügung steht: • • •  – – –  • • •
pub const BS_SOS: BlinkSeq   =   &amp;[Bc::Pause,Bc::Short,Bc::Short,Bc::Short,Bc::Pause,Bc::Long,Bc::Long,Bc::Long,Bc::Pause,Bc::Short,Bc::Short,Bc::Short];
// Hi in Morsecode:  • • • •  • • 
pub const BS_HI: BlinkSeq    =   &amp;[Bc::Short,Bc::Short,Bc::Short,Bc::Short,Bc::Pause,Bc::Short,Bc::Short];</p>

<p>#[inline(never)]
fn sleep(value: u32) {<br />
    for _ in 1..value {
        unsafe { asm!(“ “); } 
    }
}</p>

<p>pub fn blink_once(s: BlinkSeq) {
    let led_on  = GPSET1;
    let led_off = GPCLR1;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for c in s {
    let sym: Bc = c.clone();
    match sym {
        Bc::Long =&amp;gt; {
            unsafe { *(led_on) = 1 &amp;lt;&amp;lt; 15; }
            sleep(Bc::Long as u32);
            unsafe { *(led_off) = 1 &amp;lt;&amp;lt; 15; }
        },
        Bc::Short =&amp;gt; {
            unsafe { *(led_on) = 1 &amp;lt;&amp;lt; 15; }
            sleep(Bc::Short as u32);
            unsafe { *(led_off) = 1 &amp;lt;&amp;lt; 15; }
        }
        Bc::Pause =&amp;gt; {
            sleep(Bc::Pause as u32);
        }
    }
    sleep(Bc::Short as u32);
} }
</code></pre>
</div>

<p>pub fn blink(s: BlinkSeq) {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>loop {
    blink_once(s);
    sleep(200000);
} }
</code></pre>
</div>

<p>Man beachte, dass die auch hier benutzte Verzögerung durch „<em>busy idling</em>“ so nicht funktioniert, wenn wir die Codeoptimierung einschalten: Dann wird die Schleife einfach wegoptimiert. Allerdings besteht bisher für eine Optimierung noch kein Grund – die Ausführungszeit ist derzeit noch egal, aber die Übersetzungszeit würde sich etwas verlängern.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  Die Darstellung des Boot-Prozesses ist etwas vereinfacht. &amp;#8629;


  Diese Information ist eigentlich überflüssig, da sie sich später im Binärfile nicht mehr wiederfindet. Der Linker braucht sie aber, er würde sonst das Fehlen monieren. &amp;#8629;


  Vielleicht werde ich in späteren Folgen nochmal cargo oder die Cross-Compile-Variante xargo einsetzen. &amp;#8629;


  Vergleiche https://github.com/dwelch67/raspberrypi/tree/master/armjtag. &amp;#8629;


  Schon Garn nicht in meiner Arbeitsumgebung auf dem Mac, da der Debugger hier auf MachO ausgelegt ist &amp;#8629;
</code></pre>
</div>

