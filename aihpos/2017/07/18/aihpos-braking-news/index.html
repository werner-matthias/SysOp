<!doctype html>
<html class="no-js" lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Breaking News</title>
	<link rel="stylesheet" type="text/css" href="https://werner-matthias.github.io/SysOp/assets/css/styles_feeling_responsive.css" />
	<script src="https://werner-matthias.github.io/SysOp/assets/js/modernizr.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
      }
    });
  </script>

  <noscript>
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css' />
  </noscript>

  
	
	<meta name="description" content="So ist das mit &quot;unstable&quot; Versionen: Kaum kommt man nach zwei Wochen von einer Reise zurück, schon funktioniert die Übersetzung nicht mehr -- in diesem ist Fall der Heap kaputt."/>

	

	



	
	<link rel="icon" sizes="32x32" href="https://werner-matthias.github.io/SysOp/assets/img/favicon-32x32.png" />




	
	<link rel="icon" sizes="192x192" href="https://werner-matthias.github.io/SysOp/assets/img/touch-icon-192x192.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-180x180-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-152x152-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-144x144-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-120x120-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-114x114-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-76x76-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-72x72-precomposed.png" />




	
	<link rel="apple-touch-icon-precomposed" href="https://werner-matthias.github.io/SysOp/assets/img/apple-touch-icon-precomposed.png" />	




	
	<meta name="msapplication-TileImage" content="https://werner-matthias.github.io/SysOp/assets/img/msapplication_tileimage.png" />




	
	<meta name="msapplication-TileColor" content="#fabb00" />



	<!-- Facebook Optimization -->
	<meta property="og:locale" content="en_EN" />
	
	<meta property="og:title" content="Breaking News" />
	<meta property="og:description" content="So ist das mit &quot;unstable&quot; Versionen: Kaum kommt man nach zwei Wochen von einer Reise zurück, schon funktioniert die Übersetzung nicht mehr -- in diesem ist Fall der Heap kaputt." />
	<meta property="og:url" content="https://werner-matthias.github.io/SysOp//aihpos/2017/07/18/aihpos-braking-news/" />
	<meta property="og:site_name" content="Systems Operational" />
	

	

	<!-- Search Engine Optimization -->
	

	<link type="text/plain" rel="author" href="https://werner-matthias.github.io/SysOp/humans.txt" />

	

	
</head>
   <script type="text/javascript"
      src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   </script>
</head>
<body id="top-of-page" class="page-fullwidth">
	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="https://werner-matthias.github.io/SysOp" class="icon-tree"> Systems Operational</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        

              

          
          
        

              

          
          
        

              

          
          
        

              

          
          
            
            
              <li class="divider"></li>
              <li><a href="https://werner-matthias.github.io/SysOp/about/">Über mich</a></li>

            
            
          
        
        
      </ul>

      <ul class="left">
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/">Start</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          

            
            

              <li class="has-dropdown">
                <a href="https://werner-matthias.github.io/SysOp/blog/">Blog</a>

                  <ul class="dropdown">
                    

                      

                      <li><a href="https://werner-matthias.github.io/SysOp/blog/archive/">Archive</a></li>
                    
                  </ul>
                  
              </li>
              <li class="divider"></li>
            
          
        

              

          
          

            
            
              <li><a href="https://werner-matthias.github.io/SysOp/blog/aihpos/">aihPos</a></li>
              <li class="divider"></li>

            
            
          
        

              

          
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead-no-image-header">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="https://werner-matthias.github.io/SysOp" title="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
				<img src="https://werner-matthias.github.io/SysOp/assets/img/logo.png" alt="Systems Operational – Matthias Werners selten gepflegtes Blog über Computer und Menschen">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->









	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Ein Betriebsystem für die Lehre</p>
				<h1>Breaking News</h1>
			</header>

			

			<span itemprop="articleSection">
	                <p><strong>Inhalt</strong></p>
<ul id="markdown-toc">
  <li><a href="#sophia-wir-haben-ein-problem" id="markdown-toc-sophia-wir-haben-ein-problem"><img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png">, wir haben ein Problem</a>    <ul>
      <li><a href="#missing-feature" id="markdown-toc-missing-feature">Missing Feature</a></li>
      <li><a href="#auf-der-suche-nach-dem-verlorenen-attribut" id="markdown-toc-auf-der-suche-nach-dem-verlorenen-attribut">Auf der Suche nach dem verlorenen Attribut</a></li>
    </ul>
  </li>
  <li><a href="#auf-zu-neuen-ufern" id="markdown-toc-auf-zu-neuen-ufern">Auf zu neuen Ufern</a>    <ul>
      <li><a href="#allokator-api" id="markdown-toc-allokator-api">Allokator-API</a></li>
      <li><a href="#am-rande-des-speichers" id="markdown-toc-am-rande-des-speichers">Am Rande des Speichers</a></li>
    </ul>
  </li>
  <li><a href="#blick-zurück-in-freude" id="markdown-toc-blick-zurück-in-freude">Blick zurück in Freude</a></li>
</ul>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/LINK"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<div class="row"></div>

<h2 id="sophia-wir-haben-ein-problem"><img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png">, wir haben ein Problem</h2>
<h3 id="missing-feature">Missing Feature</h3>
<p>Für fast zwei Wochen war ich in Bulgarien. Danach erhielt ich beim ersten Übersetzungsversuch des <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png">-Codes eine Fehlermeldung:</p>
<div class="window">
          <nav class="control-window">
            <a href="#finder" class="close" data-rel="close">close</a>
            <a href="#" class="minimize">minimize</a>
            <a href="#" class="deactivate">deactivate</a>
          </nav>
          <h1 class="titleInside">Terminal</h1>
          <div class="container"><div class="terminal"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span></pre></td><td class="code"><pre><code><span class="line output">error[E0557]: feature has been removed
</span><span class="line output"> --&gt; libs/kalloc/src/lib.rs:1:12
</span><span class="line output">  |
</span><span class="line output">1 | #![feature(allocator)] 
</span><span class="line output">  |            ^^^^^^^^^
</span><span class="line output">
</span><span class="line output">error: The attribute `allocator` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)
</span><span class="line output"> --&gt; libs/kalloc/src/lib.rs:2:1
</span><span class="line output">  |
</span><span class="line output">2 | #![allocator]
</span><span class="line output">  | ^^^^^^^^^^^^^
</span><span class="line output">  |
</span><span class="line output">  = help: add #![feature(custom_attribute)] to the crate attributes to enable
</span><span class="line output">
</span><span class="line output">error: aborting due to 2 previous errors</span></code></pre></td></tr></table></div></div>
        </div>

<p>Natürlich fiel die Fehlermeldung nicht einfach so vom Himmel, ich hatte vorher – wie ich das regelmäßig tue – meine Toolchain mit <code class="highlighter-rouge">rustup update</code> aktualisiert.
Selbstverständlich hätte ich jetzt meine Toolchain auch wieder zurück setzen können, aber ich möchte, dass <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> mit der jeweilig aktuellen Toolchain übersetzbar ist.
Und da ich „nightly“ nutze, können solche abrupten Wechsel schon mal vorkommen. Also wird erstmal nichts aus der Erweiterung unseres Betriebssystem, sondern es heißt, den bestehenden Code wieder
lauffähig zu machen.</p>

<h3 id="auf-der-suche-nach-dem-verlorenen-attribut">Auf der Suche nach dem verlorenen Attribut</h3>
<p>Wie die Fehlermeldung angibt, wurde das Feature <code class="highlighter-rouge">#![allocator]</code> entfernt. Was nun? Ein <code class="highlighter-rouge">rustc --explain E0557</code> hilft hier nicht weiter, und das angegebene Issue in GitHub
beschäftigt sich mit Customer-Attributen. Vielleicht braucht man das Attribut nicht mehr, es reicht, dass die Funktionen vorhanden sind?
Ein einfaches Auskommentieren hilft nicht:</p>
<div class="window">
          <nav class="control-window">
            <a href="#finder" class="close" data-rel="close">close</a>
            <a href="#" class="minimize">minimize</a>
            <a href="#" class="deactivate">deactivate</a>
          </nav>
          <h1 class="titleInside">Terminal</h1>
          <div class="container"><div class="terminal"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span>
<span class="line-number">&nbsp;</span></pre></td><td class="code"><pre><code><span class="line output">error: no #[default_lib_allocator] found but one is required; is libstd not linked?
</span><span class="line output"> 
</span><span class="line output">error: cannot continue compilation due to previous error
</span><span class="line output">
</span><span class="line output">error: Could not compile `aihPOS`.</span></code></pre></td></tr></table></div></div>
        </div>
<p>Aha, sollte das Attribut einfach bloß umbenannt worden sein? Leider nein, <code class="highlighter-rouge">#![allocator]</code> war ein modulweites Attribut, im Gegensatz zu <code class="highlighter-rouge">#[default_lib_allocator]</code>. Im
„<a href="https://doc.rust-lang.org/unstable-book/">Unstable Book</a>“ ist <code class="highlighter-rouge">#[default_lib_allocator]</code> nicht aufgeführt. Allerdings hilft der
GitHup-<a href="https://github.com/rust-lang/rust/issues/27389">Issue</a> zu  <code class="highlighter-rouge">#![allocator]</code> weiter: Es verweist auf einen anderen Issue,
<a href="https://github.com/rust-lang/rust/pull/42727">#42727</a>, der wiederum auf anderes verweist, u.a. Issue <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a> und
die RFCs <a href="https://github.com/rust-lang/rfcs/blob/master/text/1974-global-allocators.md">RFC 1974</a> und
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1398-kinds-of-allocators.md">RFC 1398</a>. Daraus ergibt sich ein stimmiges Bild: Das Allokator-Interface wurde
überarbeitet und durch eine neue API ersetzt.</p>

<p>Im Folgendem wird beschrieben, wie das Allokator-Interface nun aussieht. Die entsprechenden Aussagen aus der Folge <a href="/aihpos/2017/06/07/aihpos-heap/">„Wir machen einen Haufen“</a> dieser
Reihe sind als überholt zu betrachten.</p>

<h2 id="auf-zu-neuen-ufern">Auf zu neuen Ufern</h2>
<h3 id="allokator-api">Allokator-API</h3>
<p>Ein Allokator (im allgemeinen) ist eine Struktur, die den <code class="highlighter-rouge">Allocator</code>-Trait implementiert. Der Trait ist zwar im Crate <code class="highlighter-rouge">alloc</code> definiert, aber derzeit<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>
noch nicht in der offiziellen <a href="https://doc.rust-lang.org/alloc/index.html">Dokumentation</a>. Die Quellfiles sind aber ausführlich kommentiert.</p>

<p>Der Trait besteht aus folgenden Funktionen:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">Allocator</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">);</span>
	
    <span class="k">fn</span> <span class="nf">oom</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">AllocErr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">!</span><span class="p">;</span>
	
    <span class="k">fn</span> <span class="nf">usable_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>
	
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">realloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
                      <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
                      <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">,</span>
                      <span class="n">new_layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span><span class="p">;</span>
					  
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc_zeroed</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span><span class="p">;</span>
					  
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Excess</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span><span class="p">;</span>
	
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">realloc_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
                             <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
                             <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">,</span>
                             <span class="n">new_layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Excess</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span><span class="p">;</span>
							 
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">grow_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
                            <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
                            <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">,</span>
                            <span class="n">new_layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">CannotReallocInPlace</span><span class="o">&gt;</span><span class="p">;</span>
							
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">shrink_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
                              <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
                              <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">,</span>
                              <span class="n">new_layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">CannotReallocInPlace</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">alloc_one</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span>
        <span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">;</span>
	
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">dealloc_one</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">alloc_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span>
        <span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">realloc_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
                               <span class="n">ptr</span><span class="p">:</span> <span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
                               <span class="n">n_old</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
                               <span class="n">n_new</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span>
        <span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">dealloc_array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">Unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">AllocErr</span><span class="o">&gt;</span>
        <span class="n">where</span> <span class="n">Self</span><span class="p">:</span> <span class="n">Sized</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Müssen jetzt wirklich fünfzehn Funktionen implementiert werden? Und die neuen Typen, <code class="highlighter-rouge">Layout</code>, <code class="highlighter-rouge">AllocErr</code>, <code class="highlighter-rouge">Excess</code>, <code class="highlighter-rouge">CannotReallocInPlace</code>?
Tatsächlich sieht die Sache viel freundlicher aus: Nur zwei der Funktionen sind obligatorisch, nämlich <code class="highlighter-rouge">alloc()</code> und <code class="highlighter-rouge">dealloc()</code>. Alle anderen haben sinnvolle
Standardimplementationen (<em>defaults</em>).</p>

<p><code class="highlighter-rouge">Layout</code> ist eine Struktur, die einen Speicherrequest beschreibt. Sie hat u.a. die beiden Methoden:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
</code></pre></div></div>
<p>und</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">align</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
</code></pre></div></div>

<p>Der Summentyp<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> <code class="highlighter-rouge">AllocErr</code> ist – wie der Name vorschlägt – für den Fehlerbericht bei der Allozierung zuständig. Er ist wie folgt definiert:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Clone</span><span class="p">,</span> <span class="n">PartialEq</span><span class="p">,</span> <span class="nb">Eq</span><span class="p">,</span> <span class="n">Debug</span><span class="p">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">AllocErr</span> <span class="p">{</span>
    <span class="n">Exhausted</span> <span class="p">{</span> <span class="n">request</span><span class="p">:</span> <span class="n">Layout</span> <span class="p">},</span>
    <span class="n">Unsupported</span> <span class="p">{</span> <span class="n">details</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Alle anderen Dinge braucht man zunächst einmal nicht (können aber später zur besseren Effizienz genutzt werden). Es ist somit jetzt einfach, die Kompatibilität zum früheren
Interface wieder herzustellen.</p>

<p>Die Allokator-API gilt für alle Allokatoren, Rust unterstützt
Hierarchien von Allokatoren. Am Ende wird irgendwann die
Speicherverwaltung des Betriebssystems von die 
Standardbibliothek gerufen. Existiert kein solches (wie in unserem
Fall) oder wird nur die Standardbibliothek nicht eingebunden, aber
trotzdem Crates benutzt, die Allozierungen vornehmen wollen, muss ein
globaler Allokator angegeben werden. Dies wird einfach gemacht, indem
einer Instanz einer Allokator-Struktur mit dem Attribut
<code class="highlighter-rouge">#[global_allocator]</code> dazu erklärt wird. Warum bei der Fehlermeldung
oben dieses Attribut – das übrigens auch noch keinen Eintrag im 
<a href="https://doc.rust-lang.org/unstable-book/">Unstable Book</a> hat – nicht
genannt wurde, sondern <code class="highlighter-rouge">#[default_lib_allocator]</code> ist mir nicht ganz
klar; vermutlich ist das bloß 
noch nicht stabilisiert.</p>

<h3 id="am-rande-des-speichers">Am Rande des Speichers</h3>
<p>Ich nutze die Gelegenheit und implementiere eine eigene
Heapverwaltung. Dazu nutze ich das <em>Boundary-Tag-Verfahren</em> <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. Das
hat den Vorteil, dass die Wiedereingliederung von zurückgegebenen
Speicher eine konstante Komplexität \(\mathcal{O}(1)\) hat, jedoch
auf Kosten des Speicherverbrauchs: Jeder belegte Speicherabschnitt hat
zwei Tags Verwaltungsinformation, in denen die Größe des Abschnitts
und Statusflags stehen. In meiner Implementation ist ein Tag ein
<code class="highlighter-rouge">usize</code> (genauer: eine <code class="highlighter-rouge">struct</code> mit einem <code class="highlighter-rouge">usize</code>), so dass jeweils
pro Block 8 Bytes Overhead entstehen. Da es durch die
Alignmentanforderungen ohnehin zu Verschnitt kommt, halte ich dies für
vertretbar.</p>

<p><img src="https://werner-matthias.github.io/SysOp/images/boundary.png" alt="" class="img-responsive" /></p>

<p>Um einen Speicherbereich zu belegen, wird einfach die Freispeicherliste durchsucht:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="k">self</span><span class="py">.first</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
    <span class="k">for</span> <span class="k">mut</span> <span class="n">mr</span> <span class="n">in</span> <span class="n">start</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">mr</span><span class="nf">.is_sufficient</span><span class="p">(</span><span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">mr</span><span class="nf">.allocate</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">AllocErr</span><span class="p">::</span><span class="n">Exhausted</span><span class="p">{</span><span class="n">request</span><span class="p">:</span> <span class="n">layout</span><span class="p">})</span>
<span class="p">}</span>

</code></pre></div></div>
<p>Die eigentliche „Arbeit“ liegt bei der <code class="highlighter-rouge">allocate</code>-Methode des
Speicherabschnitts: Hier wir überprüft, ob der Abschnitt als Ganzes
belegt werden soll, oder ob er aufgeteilt wird. Im letzteren Fall wird
die Teilung durchgeführt; der abgetrennte Bereich nimmt den Platz des
ursprünglichen Abschnittes in der Liste ein.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">allocate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="k">-&gt;</span>  <span class="n">Result</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">AllocErr</span><span class="o">&gt;</span>  <span class="p">{</span>
    <span class="k">let</span> <span class="n">dest_addr</span> <span class="o">=</span> <span class="nf">align_up</span><span class="p">(</span><span class="k">self</span><span class="nf">.client_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span><span class="n">layout</span><span class="nf">.align</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">front_padding</span> <span class="o">=</span> <span class="n">dest_addr</span> <span class="err">-</span> <span class="k">self</span><span class="nf">.client_addr</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">needed_size</span> <span class="o">=</span> <span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="nf">align_up</span><span class="p">(</span><span class="n">front_padding</span> <span class="o">+</span> <span class="n">layout</span><span class="nf">.size</span><span class="p">(),</span><span class="nn">mem</span><span class="p">::</span><span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">()),</span>
                               <span class="nn">Self</span><span class="p">::</span><span class="nf">min_size</span><span class="p">());</span>
    <span class="c">// Vorgänger und Nachfolger in der Liste (so vorhanden)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev</span> <span class="o">=</span> <span class="k">self</span><span class="py">.prev</span><span class="nf">.map_or</span><span class="p">(</span><span class="nb">None</span><span class="p">,|</span> <span class="n">a</span> <span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.next</span><span class="nf">.map_or</span><span class="p">(</span><span class="nb">None</span><span class="p">,|</span> <span class="n">a</span> <span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="p">);</span>
    <span class="c">// Lohnt es sich, den Bereich zu teilen?</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.size</span> <span class="err">-</span> <span class="n">needed_size</span> <span class="o">&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="nf">min_size</span><span class="p">()</span>  <span class="p">{</span> <span class="c">// Teile den Bereich</span>
        <span class="c">// Initialisere den neuen Bereich.</span>
        <span class="k">let</span> <span class="n">old_size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.set_size</span><span class="p">(</span><span class="n">needed_size</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_mr</span> <span class="o">=</span> <span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="c">// Da der neue Bereich hinten abgetrennt wird, gibt es stets einen Vorgänger</span>
        <span class="n">new_mr</span><span class="nf">.init</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.end_addr</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">()),</span>
                    <span class="n">old_size</span> <span class="err">-</span> <span class="k">self</span><span class="py">.size</span> <span class="err">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">(),</span>
                    <span class="k">self</span><span class="py">.next</span><span class="p">,</span> <span class="k">self</span><span class="py">.prev</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">self</span><span class="py">.upper_guard</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">(),</span> <span class="k">self</span><span class="py">.size</span> <span class="o">+</span> <span class="n">new_mr</span><span class="py">.size</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.upper_guard</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="c">// Setze Liste auf abgetrennten Bereich um</span>
        <span class="n">prev</span><span class="nf">.map_or</span><span class="p">((),|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.set_next_addr</span><span class="p">(</span><span class="n">new_mr</span><span class="py">.addr</span><span class="p">));</span>
        <span class="n">next</span><span class="nf">.map_or</span><span class="p">((),|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.set_prev_addr</span><span class="p">(</span><span class="n">new_mr</span><span class="py">.addr</span><span class="p">));</span>
        <span class="n">new_mr</span><span class="nf">.write_to_memory</span><span class="p">();</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c">// Belege den gesamten Bereich</span>
        <span class="c">// Entferne Bereich aus der Liste</span>
        <span class="k">self</span><span class="py">.free</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">prev</span><span class="nf">.map_or</span><span class="p">((),|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.set_next_addr</span><span class="p">(</span><span class="k">self</span><span class="py">.next</span><span class="p">));</span>
        <span class="n">next</span><span class="nf">.map_or</span><span class="p">((),</span> <span class="p">|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.set_prev_addr</span><span class="p">(</span><span class="k">self</span><span class="py">.prev</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">prev</span><span class="nf">.map_or</span><span class="p">((),|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.write_to_memory</span><span class="p">());</span>
    <span class="n">next</span><span class="nf">.map_or</span><span class="p">((),</span> <span class="p">|</span> <span class="k">mut</span> <span class="n">mr</span> <span class="p">|</span> <span class="n">mr</span><span class="nf">.write_to_memory</span><span class="p">());</span>
    <span class="c">// Markiere Bereich als reserviert und aktualisiere den Speicher</span>
    <span class="k">self</span><span class="py">.free</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">self</span><span class="nf">.write_to_memory</span><span class="p">();</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">dest_addr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> 
<span class="p">}</span>

</code></pre></div></div>
<p>Die Komplexität der Reservierung ist immer noch \(\mathcal{O}(n)\), wobei \(n\) die Anzahl der freien Speicherblöcke ist.
Im Unterschied zur vorherigen Lösung muss bei der Wiedereingliederung
die Liste <em>nicht</em> durchsucht werden:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">Layout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">end_tag_addr</span> <span class="o">=</span> <span class="nn">memory_region</span><span class="p">::</span><span class="nf">align_up</span><span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="n">layout</span><span class="nf">.size</span><span class="p">(),</span><span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">min_size</span><span class="p">()),</span>
                                               <span class="nn">mem</span><span class="p">::</span><span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">end_tag</span> <span class="o">=</span> <span class="nn">EndBoundaryTag</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="n">end_tag_addr</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mr</span> <span class="o">=</span> <span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="n">end_tag_addr</span> <span class="err">-</span> <span class="n">end_tag</span><span class="nf">.size</span><span class="p">()</span> <span class="err">-</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">EndBoundaryTag</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">mr</span><span class="nf">.set_free</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="c">// Prüft, ob Bereiche zusammen gelegt werden können.</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">mr</span><span class="nf">.coalesce_with_neighbors</span><span class="p">()</span>  <span class="p">{</span>
        <span class="c">// Keine physischen Nachbarn gefunden, Speicherbereich rückt an Listenanfang</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">head</span><span class="p">:</span> <span class="n">StartBoundaryTag</span> <span class="o">=</span> <span class="k">self</span><span class="py">.first</span><span class="nf">.get</span><span class="p">();</span>
        <span class="n">mr</span><span class="nf">.set_prev_addr</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.first</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">));</span>
        <span class="n">mr</span><span class="nf">.set_next_addr</span><span class="p">(</span><span class="n">head</span><span class="nf">.next</span><span class="p">());</span>
        <span class="c">// Bisheriges TOL-Element rückt hinter neues Element</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">mr</span><span class="nf">.next_addr</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="nn">MemoryRegion</span><span class="p">::</span><span class="nf">new_from_memory</span><span class="p">(</span><span class="n">next_addr</span><span class="p">);</span>
            <span class="n">next</span><span class="nf">.set_prev_addr</span><span class="p">(</span><span class="n">mr</span><span class="nf">.addr</span><span class="p">());</span>
            <span class="n">next</span><span class="nf">.write_to_memory</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c">// Listenkopf zeigt auf einzugliedernden Bereich</span>
        <span class="n">head</span><span class="nf">.set_next</span><span class="p">(</span><span class="n">mr</span><span class="nf">.addr</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.first</span><span class="nf">.set</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="n">mr</span><span class="nf">.write_to_memory</span><span class="p">();</span>
    <span class="p">}</span>

</code></pre></div></div>
<p>Das ist natürlich nur ein Teil des Gesamtcodes, der vollständige Code ist wieder
auf <a href="https://github.com/werner-matthias/aihPOS/tree/5fbe76b768b21e2b28277a212a8f898bbfb94f74/kernel/src/mem/heap">GibHub</a> zu finden.</p>

<h2 id="blick-zurück-in-freude">Blick zurück in Freude</h2>
<p>Nachdem ich die mein neuer Allokator tadellos lief, stellte ich fest, dass die von mir früher verwendete Version 0.2.7 der <code class="highlighter-rouge">linked_list_allocator</code>-Bibliothek gar nicht mehr die aktuelle ist. Die
derzeit neuste Version ist 0.4.1 und hat die neue Allokator-API schon vollständig umgesetzt. Danke an den Autor Philipp Oppermann, von dem auch das Blog
„<a href="https://os.phil-opp.com">Writing an OS in Rust</a>“ stammt. Ich werde zwar in <img alt="aihPOS" style="height:.78em; vertical-align:baseline" src="/SysOp/assets/img/sophia.png"> bei meinem Boundary-Tag-Allokator bleiben, es ist aber gut zu wissen, dass es eine Alternative gibt
und dass die Community so schnell reagiert.</p>

<p><a class="left button tiny radius" href="https://werner-matthias.github.io/SysOp/LINK"><span class="icon-chevron-left"></span>Vorheriger Beitrag in AIHPOS</a></p>

<div class="row"></div>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p> 18. Juli 2017 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Ich bin mir nicht sicher, was die beste Bezeichnung im Deutschen für <code class="highlighter-rouge">enum</code> ist. Als C-Programmierer denkt man da an „Aufzählungstyp“, was aber in Rust in die Irre
    führt. „Summentyp“ ist typentheoretisch korrekt, klingt aber in meinen Ohren trotzdem eigenartig. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>D. Knuth, „The Art of Computer Programming“, 2nd Auflage, Addison Wesley, 1973, Seiten 441f. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

	                </span>
			
						<div id="page-meta" class="t30">
				<p>
					<!-- Look the author details up from the site config. -->
					
					<!-- Output author details if some exist. -->
					
					<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name" class="pr20 icon-edit"><a href="http://osg.informatik.tu-chemnitz.de/Staff/M_Werner/index.php?lang=en" target="_blank"> Matthias Werner</a></span>
				</span>
				

				
				<time class="icon-calendar pr20" datetime="2017-07-18" itemprop="datePublished"> 2017-07-18</time>
				

				<span class="icon-archive pr20"> AIHPOS</span>
				<br />
				<span class="pr20"><span class="icon-price-tag pr10"> aihPOS</span> <span class="icon-price-tag pr10"> Rust</span> <span class="icon-price-tag pr10"> Allokator</span> <span class="icon-price-tag pr10"> Heap</span> </span>
			</p>

			<div id="post-nav" class="row">
				
				<div class="small-5 columns"><a class="button small radius prev" href="https://werner-matthias.github.io/SysOp/quotes/2017/06/30/concurrency/">&laquo; Nebenläufigkeit</a></div><!-- /.small-4.columns -->
				
				<div class="small-2 columns text-center"><a class="radius button small" href="https://werner-matthias.github.io/SysOp/blog/archive/" title="Blog Archiv">Archiv</a></div><!-- /.small-4.columns -->
				
				<div class="small-5 columns text-right"><a class="button small radius next" href="https://werner-matthias.github.io/SysOp/small%20hacks/2017/08/23/reihenfolge/">Reihenfolge &raquo;</a></div><!-- /.small-4.columns -->
				
			</div>
			</div><!--  /.page-meta -->
			

	                
		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">Über diese Website</h5>

            <p class="shadow-black">
              Matthias Werners Blog. 
              <a href="https://werner-matthias.github.io/SysOp/info/">Mehr ›</a>
            </p>
          </div><!-- /.large-6.columns -->


          <div class="small-6 medium-3 large-3 large-offset-1 columns">
            
              
              <ul class="no-bullet shadow-black">
              
              </ul>
          </div><!-- /.large-4.columns -->


          <div class="small-6 medium-3 large-3 columns">
            
              
            <ul class="no-bullet shadow-black">
            
            </ul>
          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="https://werner-matthias.github.io/SysOp/assets/js/javascript.min.js"></script>














</body>
</html>

